---
layout: post
title: Kubernetes — Criando um cluster simples com o kubeadm
canonical_url: https://medium.com/@fidelissauro/kubernetes-criando-um-cluster-simples-com-o-kubeadm-e50a9eb4f4a6?source=rss-fc2fda5e9bc2------2
published: false
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*64U5gNQLBNNttvnsQdjOGA.jpeg" /></figure><p>TL;DR; Vamos aprender a criar um cluster de <strong>Kubernetes</strong> em cloud da forma mais simples possível utilizando o <strong>kubeadm</strong>. No fim desse tutorial você terá uma aplicação em Node.js entregue e replicada no cluster para ser consumida externamente via API.</p><p>Não teremos a preocupação de abordar conceitos básicos do funcionamento do <strong>Kubernetes</strong>. Para entender a arquitetura de um cluster de uma forma mais detalhada, você pode conferir a documentação nesse <a href="https://kubernetes.io/docs/concepts/overview/components/"><strong>link mágico</strong></a>.</p><h3>Arquitetura Básica</h3><p>A ideia desse tutorial é não focar em um provedor de cloud específico, você terá que levar em conta todas as peculiaridades de cada um na hora de provisionar a infra base necessária.</p><p>Nesse tutorial, teremos a seguinte estrutura</p><ul><li><strong>1 servidor master;</strong> responsável por orquestrar as operações do cluster, realizar deploys, comandar os healthchecks e etc.</li><li><strong>2 servidores workers;</strong> estes serão responsáveis por receber os pods da aplicação, fazer proxy entre os mesmos e garantir a quantidade de containers solicitada rodando entre eles.</li></ul><h3>Bootstrap inicial das máquinas do Cluster</h3><p>Precisamos rodar algumas coisinhas pra fazer o <strong>Kubernetes</strong> funcionar, como o <strong>Docker</strong> e alguns CLI’s de bootstrap e administração, como o kubectl e o mágico <strong>kubeadm</strong>. Execute esses passos em todas as máquinas do cluster, tanto master quanto os nodes.</p><h4>Instalando o Docker</h4><p>Vamos fazer o download do Docker na versão mais recente.</p><pre>apt-get update<br>apt-get install -y apt-transport-https ca-certificates curl software-properties-common<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -<br>add-apt-repository &quot;deb https://download.docker.com/linux/$(. /etc/os-release; echo &quot;$ID&quot;) $(lsb_release -cs) stable&quot;<br>apt-get update &amp;&amp; apt-get install -y docker-ce=$(apt-cache madison docker-ce | grep 17.03 | head -1 | awk &#39;{print $3}&#39;)</pre><h4>Instalando os componentes do Kubernetes (kubelet, kubeadm e kubectl)</h4><p>O <strong>Kubernetes</strong> possui uma gama muito grande de plugins, extensões e CLI’s de produtividade. Nesse exemplo, o principal agente da criação do cluster será o Kubeadm, ele irá abstrair toda a dificuldade da criação de clusters e nodes por meio do kubelet. Em seguida iremos utilizar o kubectl para executar as demais ações de administração e deploy.</p><p>Mais em detalhes:</p><ul><li><strong>kubeadm</strong> — Tool para realizar o bootstrap do Cluster</li><li><strong>kubelet</strong> — Tool que roda em todos os nodes gerenciando os papéis, iniciando pods, containers e mantendo os mesmos saudáveis.</li><li><strong>kubectl</strong> — Tool para realizar a comunicação com o cluster e executar todas as operações de orquestração.</li></ul><pre>apt-get update &amp;&amp; apt-get install -y apt-transport-https curl<br>curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -<br>cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list<br>deb http://apt.kubernetes.io/ kubernetes-xenial main<br>EOF<br>apt-get update<br><strong>apt-get install -y kubelet kubeadm kubectl</strong></pre><h4>Iniciando o Master</h4><p>Vamos iniciar o cluster utilizando o mágico kubeadm . Conecte-se no node master do cluster, após realizar a instalação do Docker e das ferramentas de CLI, e execute o comando:</p><pre>kubeadm init</pre><p>Após o termino do comando, ele irá cuspir alguns outros comandos a serem executados para finalizar a configuração, e principalmente o comando que iremos utilizar para ingressar os nodes no nosso cluster.</p><pre>Your Kubernetes master has initialized successfully!</pre><pre>To start using your cluster, you need to run the following as a regular user:</pre><pre><strong>mkdir -p $HOME/.kube<br>  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>  sudo chown $(id -u):$(id -g) $HOME/.kube/config</strong></pre><pre>You should now deploy a pod network to the cluster.<br>Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:<br>  <a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></pre><pre>You can now join any number of machines by running the following on each node<br>as root:</pre><pre>Your Kubernetes master has initialized successfully!</pre><pre>To start using your cluster, you need to run the following as a regular user:</pre><pre><strong>mkdir -p $HOME/.kube<br>  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>  sudo chown $(id -u):$(id -g) $HOME/.kube/config</strong></pre><pre>You should now deploy a pod network to the cluster.<br>Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:<br>  <a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></pre><pre>You can now join any number of machines by running the following on each node<br>as root:</pre><pre><strong>kubeadm join 172.31.85.6:6443 --token izzg7r.ueqzp7ndzxp8g5xq --discovery-token-ca-cert-hash sha256:e0244a52257be9e8cba49303e0472eb25020c6bd6c68f583653ed1700260fd0a</strong></pre><p>Agora temos que fazer algo bem importante, que é fazer deploy da rede do cluster. Neste exemplo, vamos utilizar o <a href="https://www.projectcalico.org"><strong>Project Calico</strong></a> para gerenciar a rede do nosso cluster.</p><pre>kubectl apply -f https://docs.projectcalico.org/v2.6/getting-started/kubernetes/installation/hosted/kubeadm/1.6/calico.yaml</pre><h4>Iniciando os Nodes</h4><p>Após instalarem o <strong>Docker</strong> e os CLI’s do <strong>Kubernetes</strong> em todos os nodes<strong> </strong>vamos rodar o comando informado na inicialização do cluster. Ele é baseado na seguinte estrutura.</p><pre>kubeadm join &lt;ip-do-master&gt;:6443 --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;discovery-token&gt;</pre><p>No caso do exemplo é só entrar em todos os nodes e executar</p><pre>kubeadm join 172.31.85.6:6443 --token izzg7r.ueqzp7ndzxp8g5xq --discovery-token-ca-cert-hash sha256:e0244a52257be9e8cba49303e0472eb25020c6bd6c68f583653ed1700260fd0a</pre><p>Após executar o comando gerado na criação to cluster em todos os Nodes, podemos a partir do master listar todos os nodes vinculados ao cluster.</p><pre>kubectl get nodes</pre><p>O output deverá ser parecido com:</p><pre>root@k8s-master:/home/ubuntu# kubectl get nodes<br>NAME           STATUS    ROLES     AGE       VERSION<br><strong>k8s-master     Ready     master    1h        v1.10.4<br>k8s-worker01   Ready     &lt;none&gt;    15m       v1.10.4<br>k8s-worker02   Ready     &lt;none&gt;    15m       v1.10.4</strong><br>root@k8s-master:/home/ubuntu#</pre><h4>Realizando o Deploy</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/684/1*Cbbiwf8JeEs_yVqz4ahesg.png" /></figure><p>Vamos fazer deploy de uma aplicação simples que eu criei para esse exemplo. Crie um arquivo chamado <strong>deploy.yml</strong>.</p><p>Nele vamos criar um <strong>Replication Controller</strong> para garantir a quantidade de pods que queremos rodando no cluster. Nele vamos export a porta 3000 dos containers.</p><p>Depois criar um service <strong>NodePort</strong> que irá mapear a porta do host para o container. Vamos fazer um mapeamento da porta <strong>30001</strong> dos nodes para a <strong>3000</strong> do containers. Funciona como um load balancer simplificado. Bem simples.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/819b53f50257d4f921a2b2579dc107ac/href">https://medium.com/media/819b53f50257d4f921a2b2579dc107ac/href</a></iframe><p>Agora vamos aplicar</p><pre>kubectl apply -f deploy.yml</pre><p>O output deverá ser parecido com esse:</p><pre>replicationcontroller &quot;microapi&quot; created<br>service &quot;microapi-ports&quot; created</pre><p>Vamos listar nossos pods existentes no cluster</p><pre>kubectl get pods</pre><p>O output deverá ser parecido com esse, mostrando 5 pods que estão rodando a nossa aplicação.</p><pre>NAME       DESIRED   CURRENT   READY     AGE<br>microapi   5         5         5         3m<br>NAME             READY     STATUS    RESTARTS   AGE<br>microapi-4xgj9   1/1       Running   0          3m<br>microapi-h255v   1/1       Running   0          3m<br>microapi-h9wrj   1/1       Running   0          3m<br>microapi-hk7th   1/1       Running   0          3m<br>microapi-lxv2h   1/1       Running   0          3m<br>root@k8s-master:/home/ubuntu#</pre><p>Desse modo, podemos fazer uma requisição para qualquer um dos nodes na porta 30001 para acessar os recursos da nossa API.</p><pre>curl -i <a href="http://localhost:30001/system">http://localhost:30001/system</a> #oooou<br>curl -i <a href="http://ip-do-node:30001/system">http://ip-do-node:30001/system</a> </pre><p>O output deverá apresentar informações do sistema em que o container está rodando. Faça várias requisições e veja a variação da key <strong>hostname</strong>, para validar como o proxy entre os nodes está funcionando.</p><pre>HTTP/1.1 200 OK<br>content-type: application/json; charset=utf-8<br>cache-control: no-cache<br>content-length: 322<br>accept-ranges: bytes<br>Date: Mon, 18 Jun 2018 18:12:57 GMT<br>Connection: keep-alive</pre><pre>{&quot;hostname&quot;:&quot;<strong>microapi-h255v</strong>&quot;,&quot;os&quot;:{&quot;type&quot;:&quot;Linux&quot;,&quot;platform&quot;:&quot;linux&quot;,&quot;release&quot;:&quot;4.4.0-1060-aws&quot;,&quot;arch&quot;:&quot;x64&quot;},&quot;resources&quot;:{&quot;memory&quot;:{&quot;limit&quot;:1038864384,&quot;free&quot;:174473216},&quot;cpus&quot;:[{&quot;model&quot;:&quot;Intel(R) Xeon(R) CPU E5-2676 v3 @ 2.40GHz&quot;,&quot;speed&quot;:2400,&quot;times&quot;:{&quot;user&quot;:1117800,&quot;nice&quot;:51400,&quot;sys&quot;:419300,&quot;idle&quot;:82950000,&quot;irq&quot;:0}}]}}</pre><p>Esse modo exposição do serviço usando NodePorts é muito bacana caso você tenha algum outro balanceador de carga na frente dos nodes do seu cluster, como o ALB ou ELB da AWS. Funciona que é bala :)</p><p>Algumas dicas:</p><ul><li>Esse exemplo foi construído em cima de máquinas EC2 na AWS. A ideia era não focar em nenhum provider de cloud em especifico, porém nesse caso, você vai ter que liberar o tráfego total entre os nodes para garantir um bom funcionamento.</li><li>Uma dica é criar um <strong>Security Group</strong> para o cluster e liberar todo o tráfego entre todas as portas para conexões que compartilhem o mesmo security group, dessa forma:</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/903/1*fzMw9fbzoEVXIpVlNIgaZQ.png" /></figure><p>Espero ter ajudado!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e50a9eb4f4a6" width="1" height="1" alt="">
