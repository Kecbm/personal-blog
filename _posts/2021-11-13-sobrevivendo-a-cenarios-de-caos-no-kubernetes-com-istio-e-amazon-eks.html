---
layout: post
title: Sobrevivendo a cenários de caos no Kubernetes com Istio e Amazon EKS
canonical_url: https://medium.com/@fidelissauro/sobrevivendo-a-cen%C3%A1rios-de-caos-no-kubernetes-com-istio-e-amazon-eks-4fb8469a73da?source=rss-fc2fda5e9bc2------2
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*GkLj74XrpAnGw4Dw.jpeg" /><figcaption>&quot;As famosas piadinhas com containers caindo de um cargueiro&quot;</figcaption></figure><blockquote>Na sua casa você pode usar o que você quiser, aqui hoje vamos usar Istio. Sem tempo pra chorar irmão…</blockquote><p>O objetivo desse post é apresentar alguns mecanismos de resiliência que podemos agregar em nosso Workflow para sobreviver em (alguns) cenários de caos e desastres utilizando recursos do <strong>Istio</strong> e no <strong>Amazon EKS</strong>.</p><p>Obviamente isso não é &quot;plug n&#39; play&quot; pra qualquer cenário, então espero que você absorva os conceitos e as ferramentas e consiga adaptar para o seu próprio caso.</p><p>A ideia é estabelecer uma linha de pensamento progressiva apresentando cenários de desastre de aplicações, dependências e infraestrutura e como corrigi-los utilizando as ferramentas apresentadas.</p><p>Para este post foi criado um laboratório simulando um fluxo síncrono onde temos <strong>4 microserviços </strong>que se comunicam entre si, simulando um sistema distribuído de pedidos, onde todos são estimulados por requisições HTTP.</p><h3>Premissas Iniciais:</h3><ul><li>O ambiente roda em um EKS utilizando a versão 1.20 do Kubernetes em 3 zonas de disponibilidade (us-east-1a, us-east-1b e us-east-1c)</li><li>Vamos trabalhar com um SLO de 99,99% de disponibilidade para o cliente final</li><li>O ambiente já possui <strong>Istio</strong> default com <strong>Gateways</strong> e <strong>VirtualServices</strong> Vanilla configurados pra todos os serviços</li><li>O objetivo é aumentar a resiliência diretamente no Istio, por isso nenhuma aplicação tem fluxo de circuit breaker ou retry pragmaticamente implementados.</li><li>Vamos utilizar o <strong>Kiali</strong>, <strong>Grafana</strong> para visualizar as métricas</li><li>Vamos utilizar o <a href="https://k6.io/docs/getting-started/running-k6/"><strong>K6</strong></a> para injetar carga no workload</li><li>Vamos utilizar o <a href="https://chaos-mesh.org"><strong>Chaos Mesh</strong></a> para injetar falhas de plataforma do Kubernetes</li><li>Vamos utilizar o <a href="https://github.com/msfidelis/gin-chaos-monkey"><strong>gin-chaos-monkey</strong></a> para injetar falhas a nível de aplicação diretamente no runtime</li><li>O objetivo não é avaliar arquitetura de solução, e sim focar nas ferramentas apresentadas para aumentar resiliência.</li></ul><h3>Topologia do Sistema</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*06zbZCi-J8bjNklg.png" /></figure><p>Esta é a representação do fluxo de comunicação entre as aplicações do teste. Todas são mocks mas executam chamadas entre si simulando clientes e servers reais de dominio.</p><h3>Hipótese 1: Resiliência em falhas de aplicação</h3><p>O objetivo é coletar as métricas de disponibilidade do fluxo sincrono com <strong>qualquer componente podendo falhar a qualquer momento.</strong></p><p>Primeiro teste tem o objetivo de injetar uma carga de <strong>60s</strong>, simulando <strong>20 VUS (Virtual Users) </strong>em todos os cenários, para ver como esses erros se comportam em cascata até chegar no cliente final a medida que vamos criando mecanismos de resiliência.</p><p>Todas as aplicações implementando um middlware de chaos que injeta falhas durante a requisição HTTP, portando em qualquer momento, qualquer uma delas poderá sofrer um:</p><ul><li><strong>Memory Assault</strong> — gerando memory leaks constantes</li><li><strong>CPU Assault</strong> — injetando overhead de recursos</li><li><strong>Latency Assault</strong> — incrementando o response time entre 1000ms e 5000ms</li><li><strong>Exception Assault</strong> — devolvendo aleatoriamente um status de 503 com falha na requisição</li><li><strong>AppKiller Assault</strong> — fazendo o runtime entrar em panic()</li></ul><p>Logo a hipótese a ser testada é:</p><blockquote>&quot;Minhas aplicações podem gerar erros sistêmicos aleatoriamente que mesmo assim estarei resiliente para meu cliente final&quot;</blockquote><h3>Cenários 1.1 — Cenário inicial</h3><p>Vamos rodar o teste de carga do k6 no ambiente para ver como vamos nos sair sem nenhum tipo de mecanismo de resiliência:</p><pre>k6 run --vus 20 --duration 60s k6/loadtest.js</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*8dnV7-W_UiZX3ulF.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*6mxr7uhG3y_8O8Qf.png" /></figure><p>Podemos ver que o chaos monkey da aplicação cumpriu seu papel, injetando falhas aleatórias em todas as dependências da malha de serviços, ofendendo drasticamente nosso <strong>SLO</strong> de disponibilidade pra <strong>88.10%</strong>, estourando nosso <strong>Error Budget</strong> para este período do teste.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*lM7tKCboFv60UIRH.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gbjiWkG73kofNmBD.png" /></figure><p>Podemos ver também que todas as aplicações da malha, em algum momento apresentaram falhas aleatórias, gerando erros em cascata.</p><h4>Sumário do teste 1.1 — Cenário inicial :</h4><ul><li><strong>Tempo do teste:</strong> 60s</li><li><strong>Total de requisições: </strong>13905</li><li><strong>Requests por segundo</strong>: 228.35/s</li><li><strong>Taxa de erros a partir do client:</strong> 11.91%</li><li><strong>Taxa real de sucesso do serviço principal orders-api:</strong> 88.10%</li><li><strong>Taxa de sucesso dos consumidores do orders-api:</strong> 88.10%</li><li><strong>SLO Cumprido:</strong> Não</li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/istio/00-raw-workload"><strong>Yaml dos testes executados no cenário</strong></a></li></ul><h3>Cenário 1.2 — Implementando retry para Falhas HTTP</h3><p>O objetivo do cenário é implementar a politica de retentativas para falhas HTTP nos VirtualServices previamente configurados das aplicações. Vamos as opções <strong>5xx,gateway-error,connect-failure</strong>. Podendo ocorrer até <strong>3 tentativas</strong> de retry com um<strong> timeout de 500ms</strong>.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/08744cdec8acdc055fac5d5c093db4e7/href">https://medium.com/media/08744cdec8acdc055fac5d5c093db4e7/href</a></iframe><p>As opções de retentativas iniciais de acordo com a documentação, possuem as seguintes funções:</p><ul><li><strong>5xx:</strong> Ocorrerá uma nova tentativa se o servidor upstream responder com qualquer código de resposta 5xx</li><li><strong>gateway-error:</strong> Uma politica parecida com o 5xx, porém voltadas a falhas especificas de gateway como 502, 503, or 504 no geral. Nesse caso, é redundante, porém fica de exemplo.</li><li><strong>connect-failure:</strong> Será realizada mais uma tentativa em caso de falha de conexão por parte do upstream ou em casos de timeout.</li></ul><p>Vamos rodar novamente os testes simulando 20 usuários por 60 segundos com os 3 retries aplicados.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*XL9nRme1a6MaAohe.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*CJS0_b-aCCP0T36S.png" /></figure><p>Conseguimos uma melhoria de mais de <strong>6% de disponibilidade</strong> entre o que o serviço degradado respondeu com o que o cliente recebeu, utilizando apenas 3 tentativas de retry entre todos os serviços. Tivemos já um grande saving de disponibilidade para o cliente final, porém ainda ofendemos nosso SLO, batendo <strong>99,25%</strong> de disponibilidade.</p><h4>Sumário do teste 1.2 — Retry para falhas HTTP:</h4><ul><li><strong>Tempo do teste:</strong> 60s</li><li><strong>Total de requisições:</strong> 17873</li><li><strong>Requests por segundo:</strong> 293.17/s</li><li><strong>Taxa de erros a partir do client:</strong> 0.07%</li><li><strong>Taxa real de sucesso do serviço principal orders-api:</strong> 93.08 %</li><li><strong>Taxa de sucesso dos consumidores do orders-api:</strong> 99.25%</li><li><strong>SLO Cumprido:</strong> Não</li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/istio/01-retry"><strong>Yaml dos testes executados no cenário</strong></a></li></ul><h3>Cenário 1.3 — Ajustando a quantidade de retries para suprir o cenário</h3><p>Para fechar o ciclo com o problema resolvido, aumentei o numero de retries de <strong>3</strong> para <strong>5</strong> e repeti os testes nos mesmos cenários. Em ambientes reais, esse tipo de tunning pode vir a partir de um numero magico, encontrado depois de diversas repetições do mesmo cenário de teste. Executei mais algumas vezes até chegar num numero de 0% de erros várias vezes.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/fed1e6a255fc9e4a85e29e65788cd021/href">https://medium.com/media/fed1e6a255fc9e4a85e29e65788cd021/href</a></iframe><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Ai4Dzv9e-73koWDz.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*M05f0F2d-k8u-9DS.png" /></figure><p>Neste cenário conseguimos suprir os <strong>93.09%</strong> de disponibilidade que vieram dos upstreams garantindo <strong>100%</strong> de disponibilidade para o cliente com os cenários de retry. Neste cenário de falhas aleatórias sendo injetadas, conseguimos salvar a disponibilidade final do nosso cliente.</p><h4>Sumário do teste 1.3 — Ajustes na quantidade de retries para a hipótese:</h4><ul><li><strong>Tempo do teste:</strong> 60s</li><li><strong>Total de requisições:</strong> 18646</li><li><strong>Requests por segundo: </strong>308.79/s</li><li><strong>Taxa de erros a partir do client:</strong> 0.00%</li><li><strong>Taxa real de sucesso do serviço principal orders-api:</strong> 93.09 %</li><li><strong>Taxa de sucesso dos consumidores do orders-api:</strong> 100.00%</li><li><strong>SLO Cumprido:</strong> Sim</li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/istio/02-retry-2"><strong>Yaml dos testes executados no cenário</strong></a></li></ul><p>Hipótese concluida com sucesso!!</p><h3>Hipótese 2: Resiliência em falhas dos Pods</h3><p>Para executar os testes de infraestrutura nos pods vamos utilizar o <strong>Chaos Mesh</strong> como utilitário para injetar falhas no nos componentes do nosso fluxo, e <strong>desligar o chaos-monkey </strong>do runtime das aplicações. <strong><em>A partir desde ponto, não injetaremos mais falhas intencionais a partir da aplicação</em></strong> para testarmos puramente falhas a nível da plataforma. O objetivo é analisar novamente como o nosso fluxo sincrono se comporta perdendo unidades computacionais bruscamente em diversos cenários, e como nosso fluxo de melhoria continua nos retries podem nos ajudar e agregar ainda mais valor como plataforma.</p><p>Logo a hipótese é:</p><blockquote>“Posso perder pods e unidades computacionais de diversas formas que minha aplicação continuará resiliente para o cliente final”</blockquote><h3>Cenário 2.1 — Injetando falhas de healthcheck nos componentes do workload</h3><p>Neste primeiro cenário, vamos injetar o mesmo volume de requisições, e no meio deles vamos aplicar o cenário de pod-failure no nosso fluxo. Em todas as aplicações, vamos aplicar um teste de 30s onde vamos perder <strong>90% dos nossos pods repentinamente por falha de healthcheck</strong>. Esse é um teste bem agressivo, e tem o intuito de verificar como o que fizemos até agora, agrega de valor nesse cenário.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/44212f96b37d402b3d1069fba1cbb07e/href">https://medium.com/media/44212f96b37d402b3d1069fba1cbb07e/href</a></iframe><p>Vamos colocar o teste pra rodar nos mesmos cenários e no meio dele aplicar os cenários de <strong>PodFailure</strong> do <strong>Chaos Mesh</strong> para todas as aplicações</p><pre>kubectl apply -f chaos-mesh/01-pod-failture/</pre><pre>podchaos.chaos-mesh.org/cc-pod-failure created<br>podchaos.chaos-mesh.org/clients-pod-failure created<br>podchaos.chaos-mesh.org/orders-pod-failure created<br>podchaos.chaos-mesh.org/payment-pod-failure created</pre><p>Vamos conferir o status dos pods:</p><pre>❯ kubectl get pods -n orders</pre><pre>NAME READY STATUS RESTARTS AGE</pre><pre>orders-api-fb5c94987-225zp 0/2 Running 2 100s<br>orders-api-fb5c94987-8rpjb 0/2 Running 2 14m<br>orders-api-fb5c94987-bmnqm 0/2 Running 2 85s<br>orders-api-fb5c94987-d9c4f 0/2 Running 2 14m<br>orders-api-fb5c94987-gd745 0/2 Running 2 14m<br>orders-api-fb5c94987-htbcn 2/2 Running 0 100s<br>orders-api-fb5c94987-rzqkg 0/2 Running 2 100s<br>orders-api-fb5c94987-st8l2 0/2 Running 2 85s</pre><pre>❯ kubectl get pods -n cc</pre><pre>NAME READY STATUS RESTARTS AGE</pre><pre>cc-api-548bb458-78p77 2/2 Running 0 14m<br>cc-api-548bb458-nkjmj 0/2 Running 2 14m<br>cc-api-548bb458-sgfrb 0/2 Running 2 14m</pre><pre>❯ kubectl get pods -n payment</pre><pre>NAME READY STATUS RESTARTS AGE</pre><pre>payment-api-d466c7f59-6q86t 0/2 Running 4 115s<br>payment-api-d466c7f59-pv6wd 0/2 Running 4 14m<br>payment-api-d466c7f59-q9bsv 0/2 Running 4 14m<br>payment-api-d466c7f59-zbsvs 2/2 Running 0 14m</pre><pre>❯ kubectl get pods -n clients</pre><pre>NAME READY STATUS RESTARTS AGE</pre><pre>clients-api-5c8d89b4d-8nvsd 2/2 Running 0 14m<br>clients-api-5c8d89b4d-wd8rq 0/2 Running 4 14m<br>clients-api-5c8d89b4d-xm4ln 0/2 Running 4 14m</pre><p>Vamos analisar os resultados:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*BWX0nJk52Yg2OX9S.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*DbVYcS7BHsiMcZSS.png" /></figure><p>Neste teste, 90% de todos os pods do nosso workflow pararam de responder no healthcheck repentinamente por 30s durante nosso teste de 60s. Mesmo com nosso cenário de retries entre os VirtualServices, ainda tivemos <strong>1.22%</strong> de erros retornados ao cliente. Conseguimos um saving de quase <strong>5% de erros</strong>, mas ainda assim ferimos nosso SLO de 99,99%.</p><h4>Sumário do Teste 2.1 — Injetando falhas de Healthcheck nas aplicações:</h4><ul><li><strong>Tempo do teste:</strong> 60s</li><li><strong>Total de requisições:</strong> 14340</li><li><strong>Requests por segundo:</strong> 233.75/s</li><li><strong>Taxa de erros a partir do client:</strong> 1.22%</li><li><strong>Taxa real de sucesso do serviço principal orders-api:</strong> 93.97 %</li><li><strong>Taxa de sucesso dos consumidores do orders-api</strong>: 98.69%</li><li><strong>SLO Cumprido:</strong> Não</li></ul><h3>Cenário 2.2 — Adicionando retry por conexões perdidas / abortadas</h3><p>No caso anterior, com a perda repentina de 90% dos recursos computacionais da malha, mesmo com as politicas de retentativas, tivemos um grande saving de disponibilidade mas ainda assim não batemos a meta de SLO de disponibilidade. Então vamos adicionar algumas outras politicas de retentativa que podem prever esses cenários em cascata. Vamos adicionar as opções <strong>5xx,gateway-error,connect-failure,refused-stream,reset,unavailable,cancelled</strong> no nosso <strong>retryOn. </strong>A ideia é evitar os erros de perda de conexões abertas durante uma queda brusca de pods.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5427e02434c831aa1c5e3dab3fb5212a/href">https://medium.com/media/5427e02434c831aa1c5e3dab3fb5212a/href</a></iframe><p><strong>As opções de retentativas são, de acordo com a documentação para HTTP:</strong></p><ul><li><strong>reset: </strong>Será feita uma tentativa de retry em caso de disconnect/reset/read timeout vindo do upstream</li></ul><p>Caso você esteja utilizando algum backend <strong>gRPC</strong>, tomei a liberdade de adicionar as outras opções no exemplo, caso seu backend seja exclusivamente HTTP, as mesmas não serão necessárias, mas fica como estudo:</p><ul><li><strong>resource-exhausted</strong>: retry em chamadas gRPC em caso de headers contendo o termo “resource-exhausted”</li><li><strong>unavailable</strong>: retry em chamadas gRPC em caso de headers contendo o termo “unavailable”</li><li><strong>cancelled:</strong> retry em chamadas gRPC em caso de headers contendo o termo “cancelled”</li></ul><p>Executar novamente os testes para avaliar o quanto de melhoria temos colocando o retry por disconnect/reset/timeout adicionais</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*MB3fsIzA5QlEgA2s.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*FgBEn7ANDQEugq-j.png" /></figure><p>Neste teste tivemos um saving significativo de disponibilidade, tendo um numero de 0.03% contabilizados no cliente. Poupando apenas 5 erros de 15633 requisições. Bastante coisa. Da pra melhorar? Da.</p><h4>Sumário do teste 2.2 — Adicionando Retry por Conexões Abortadas :</h4><ul><li><strong>Tempo do teste: </strong>60s</li><li><strong>Total de requisições:</strong> 15633</li><li><strong>Requests por segundo:</strong> 258.4/s</li><li><strong>Taxa de erros a partir do client: </strong>0.03%</li><li><strong>Taxa real de sucesso do serviço principal orders-api:</strong> 92.81 %</li><li><strong>Taxa de sucesso dos consumidores do orders-api:</strong> 99.99 %</li><li><strong>SLO Cumprido:</strong> Não</li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/istio/03-retry-connection"><strong>Yaml dos testes executados no cenário</strong></a></li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/chaos-mesh/01-pod-failture"><strong>Yaml dos testes do Chaos Mesh</strong></a></li></ul><h3>Cenário 2.2 — Adicionando circuit breakers nos upstreams</h3><p>Para a cereja do bolo pro assunto de resiliência em service-mesh, nesse caso o istio, são os circuit breakers. É um conceito muito legal que não é tão fácil de compreender como os retry. Circuit breakers nos ajudam a sinalizar pros clientes que um determinado serviço está fora, poupando esforço para consumi-lo e junto com as retentativas estar sempre validando se os mesmos estão de volta “a ativa” ou não. Isso vai nos ajudar a “não tentar” mais requisições nos hosts que atenderem aos requisitos de circuito quebrado. Além de poder limitar a quantidade de requisições ativas que nosso backend consegue atender, para evitar uma degradação maior ou gerar uma falha não prevista. Para isso vamos adicionar um recurso chamado <strong>DestinationRule </strong>em todas as aplicações da malha de serviço.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6b98104b7d162aead1d7edfc61a20441/href">https://medium.com/media/6b98104b7d162aead1d7edfc61a20441/href</a></iframe><p>As coisas mais importantes desse novo objeto são <strong>consecutive5xxErrors</strong> e <strong>baseEjectionTime</strong>.</p><p>Os <strong>consecutive5xxErrors</strong> é o numero de erros que um upstream pode retornar para que o mesmo seja considerado com o circuito aberto.</p><p>Já o <strong>baseEjectionTime</strong> é o tempo que o host ficará com o circuito aberto antes de retornar para a lista de upstreams.</p><p>Peguei essas duas imagens deste<a href="https://sfeir.github.io/kubernetes-istio-workshop/kubernetes-istio-workshop/1.0.0/istio/07_circuit-breaker.html"><strong> post excelente a respeito de circuit-breaking do Istio</strong></a> mais conceitual, e de como ele funciona em conjunto com os retries que já implementamos.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/650/0*oXPDpAO-L0mnkv5f.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/651/0*foWKYRRU_5GlP-GY.png" /></figure><p>A partir do momento que o baseline de erros de um upstream ativa a quebra de circuito, o upstream fica inativa na lista pelo período recomendado pelo <strong>Pool Ejection</strong>, e com as considerações de retry, podemos iterar na lista até encontrar um host saudável para aquela requisição em específico.</p><p>Seguindo essa lógica, vamos aos testes:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*8mj6t2h8l2mtY_3S.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*UGSKcM34HWbjm5J2.png" /></figure><p>Neste teste finalmente conseguimos atingir os 100% de disponibilidade com falha temporária e repentina de 90% do healthcheck das aplicações da malha. No <strong>Kiali</strong>, podemos ver que o circuit breaker foi implementado em todas as pontas do workflow.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*RpfIlWVVRzOsDxFb.png" /></figure><h4>Sumário do teste 2.3 — Adicionando Circuit Breaker com os Retry:</h4><ul><li><strong>Tempo do teste: </strong>60s</li><li><strong>Total de requisições:</strong> 20557</li><li><strong>Requests por segundo:</strong> 342/s</li><li><strong>Taxa de erros a partir do client:</strong> 0.00%</li><li><strong>Taxa real de sucesso do serviço principal orders-api:</strong> 100 %</li><li><strong>Taxa de sucesso dos consumidores do orders-api:</strong> 100 %</li><li><strong>SLO Cumprido:</strong> SIM</li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/istio/04-circuit-breaker"><strong>Yaml dos testes executados no cenário</strong></a></li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/chaos-mesh/01-pod-failture"><strong>Yaml dos testes do Chaos Mesh</strong></a></li></ul><h4>Cenário 2.3 — Morte instantânea de 90% dos pods</h4><p>Vamos avaliar um outro cenário, parecido mas não igual. No cenário anterior validamos a action pod-failure, que injeta uma falha de healthcheck nos pods mas não os mata definitivamente. Nesta vamos executar a action <strong>pod-kill,</strong> onde 90% dos pods vão sofrer um force terminate.</p><p>Vamos iniciar o teste de carga e no meio dela vamos injetar a falha no workload.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ce62cf2aa128e0c5c0379a36b0f3031c/href">https://medium.com/media/ce62cf2aa128e0c5c0379a36b0f3031c/href</a></iframe><pre>kubectl apply -f chaos-mesh/02-pod-kill</pre><pre>podchaos.chaos-mesh.org/cc-pod-kill created<br>podchaos.chaos-mesh.org/clients-pod-kill created<br>podchaos.chaos-mesh.org/orders-pod-kill created<br>podchaos.chaos-mesh.org/payment-pod-kill created</pre><p>Vamos verificar se os pods realmente cairam repentinamente como o esperado:</p><pre>❯ kubectl get pods -n payment</pre><pre>NAME READY STATUS RESTARTS AGE</pre><pre>payment-api-645c7958cd-c25nf 2/2 Running 0 2m40s<br>payment-api-645c7958cd-clbpg 1/2 Running 0 6s<br>payment-api-645c7958cd-h6fgh 0/2 Running 0 6s<br>payment-api-645c7958cd-lt5bp 0/2 PodInitializing 0 6s<br>payment-api-645c7958cd-s2gzx 0/2 Running 0 6s<br>payment-api-645c7958cd-v6c8w 0/2 Running 0 6s</pre><pre>❯ kubectl get pods -n orders</pre><pre>NAME READY STATUS RESTARTS AGE</pre><pre>orders-api-86b4c65f9b-6wdg5 1/2 Running 0 18s<br>orders-api-86b4c65f9b-pvqv4 1/2 Running 0 18s<br>orders-api-86b4c65f9b-wbkt2 2/2 Running 0 4m13s</pre><pre>❯ kubectl get pods -n cc</pre><pre>NAME READY STATUS RESTARTS AGE</pre><pre>cc-api-58b558fc8f-6dqlh 2/2 Running 0 15m<br>cc-api-58b558fc8f-7zz8t 1/2 Running 0 30s<br>cc-api-58b558fc8f-wnjcs 1/2 Running 0 30s</pre><pre>❯ kubectl get pods -n clients</pre><pre>NAME READY STATUS RESTARTS AGE</pre><pre>clients-api-59b5cf8bc-46cws 1/2 Running 0 47s<br>clients-api-59b5cf8bc-4rkvp 1/2 Running 0 47s<br>clients-api-59b5cf8bc-hdngf 1/2 Running 0 47s<br>clients-api-59b5cf8bc-txcb4 2/2 Running 0 16m<br>clients-api-59b5cf8bc-vb8lh 1/2 Running 0 47s</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-KYAb_g8yLMawC1C.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-usGzAssLp06vQj-.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*nG5I6FCTYos_MMig.png" /></figure><p>Desta vez passamos de primeira no teste de uma queda brusca de pods com carga quente. Os retries com circuit breaker dos pods agiram muito rápido evitando uma quantidade significativa de retries, melhorando muito até o response time e tput.</p><h4>Sumário do teste 2.3 — Morte repentina dos pods das aplicações:</h4><ul><li><strong>Tempo do teste: </strong>60s</li><li><strong>Total de requisições:</strong> 24948</li><li><strong>Requests por segundo:</strong> 415,56/s</li><li><strong>Taxa de erros a partir do client: </strong>0.00%</li><li><strong>Taxa real de sucesso do serviço principal orders-api:</strong> 100 %</li><li><strong>Taxa de sucesso dos consumidores do orders-api:</strong> 100 %</li><li><strong>SLO Cumprido:</strong> SIM</li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/istio/04-circuit-breaker"><strong>Yaml dos testes executados no cenário</strong></a></li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/chaos-mesh/02-pod-kill"><strong>Yaml dos testes do Chaos Mesh</strong></a></li></ul><p>Hipótese validada com sucesso!</p><h3>Hipótese 3: Queda de Uma Zona de Disponibilidade no EKS</h3><p>Neste laboratório estamos rodando o EKS com 3 AZ’s na região de <strong>us-east-1,</strong> sendo <strong>us-east-1a</strong>, <strong>us-east-1b</strong>, <strong>us-east-1c</strong> rodando com 2 EC2 em cada uma delas.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*H1_kA2meMfrpKcOM.png" /></figure><p>A idéia e matar todas as instâncias de uma determinada zona de disponibilidade especifica para validar se quantidade de retries e circuit breaker que implementamos até o momento são capazes de suprir esse cenário em disponibilidade.</p><p>Logo a hipótese é:</p><blockquote>Os recursos computacionais de uma zona de disponibilidade especifica pode cair a qualquer momento que estarei resiliente para meus clientes finais</blockquote><h4>Cenário 3.1 — Morte de uma zona de disponibilidade da AWS</h4><p>Antes de mais nada, vamos utilizar o recurso do <strong>PodAffinity</strong> / <strong>PodAntiAffinity</strong> para criar uma sugestão de regra para o scheduler: “<em>divida-se igualmente entre os hosts utilizando a referencia a label failure-domain.beta.kubernetes.io/zone</em>”, na qual é preenchida nos nodes do <strong>EKS</strong> com a zona de disponibilidade que aquele node está rodando, o que irá acarretar em garantir um <strong>Multi-AZ</strong> do workload.</p><pre>❯ kubectl describe node ip-10-0-89-102.ec2.internal</pre><pre>Name: ip-10-0-89-102.ec2.internal<br>Roles: &lt;none&gt;<br>Labels: beta.kubernetes.io/arch=amd64<br>beta.kubernetes.io/instance-type=t3.large<br>beta.kubernetes.io/os=linux<br>eks.amazonaws.com/capacityType=ON_DEMAND<br>eks.amazonaws.com/nodegroup=eks-cluster-node-group<br>eks.amazonaws.com/nodegroup-image=ami-0ee7f482baec5230f<br>failure-domain.beta.kubernetes.io/region=us-east-1<br>failure-domain.beta.kubernetes.io/zone=us-east-1c<br>ingress/ready=true<br>kubernetes.io/arch=amd64<br>kubernetes.io/hostname=ip-10-0-89-102.ec2.internal<br>kubernetes.io/os=linux<br>node.kubernetes.io/instance-type=t3.large<br>topology.kubernetes.io/region=us-east-1<br><strong>topology.kubernetes.io/zone=us-east-1c</strong> <strong>&lt;----------- AQUI</strong><br>Annotations: node.alpha.kubernetes.io/ttl: 0<br>volumes.kubernetes.io/controller-managed-attach-detach: true</pre><p>Então, em todos os nossos arquivos de deployment vamos adicionar as notações de affinity</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5653bbb01b1c5023aba9bde94c7c5811/href">https://medium.com/media/5653bbb01b1c5023aba9bde94c7c5811/href</a></iframe><p>Vamos olhar os pods de uma aplicação especifica para encontrar os IP&#39;s que eles assumiram na VPC para identificar a distribuição via console</p><pre>❯ kubectl get pods -n orders -o wide</pre><pre>NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES</pre><pre>orders-api-56f8bf5b7c-7wbz4 2/2 Running 0 2m10s <strong>10.0.54.38</strong> ip-10-0-58-137.ec2.internal &lt;none&gt; &lt;none&gt;</pre><pre>orders-api-56f8bf5b7c-pcqtd 2/2 Running 0 2m10s <strong>10.0.89.56</strong> ip-10-0-81-235.ec2.internal &lt;none&gt; &lt;none&gt;</pre><pre>orders-api-56f8bf5b7c-zlwgd 2/2 Running 0 2m10s <strong>10.0.78.253</strong> ip-10-0-76-14.ec2.internal &lt;none&gt; &lt;none&gt;</pre><p>Levando os IP’s dos pods para o painel, podemos ver se a sugestão está funcionando entre as 3 zonas de disponibilidade.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*11JWmXUiwDPZBnEX.png" /></figure><p>Este teste não será tão inteligente. Vou selecionar todos os nodes da zona us-east-1a e dar um halt via SSM enquanto nosso teste roda.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*pZIQqoTzpVeXphAJ.png" /></figure><p>Vamos aos resultados do teste</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Dpuuhfq8qV0ogOcU.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*SBuHF7Twxx7sKE17.png" /></figure><h4>Sumário dos testes 3.1 — Perda de uma AZ:</h4><ul><li><strong>Tempo do teste:</strong> 60s</li><li><strong>Total de requisições:</strong> 23136</li><li><strong>Requests por segundo:</strong> 385.11/s</li><li><strong>Taxa de erros a partir do client:</strong> 0.00%</li><li><strong>Taxa real de sucesso do serviço principal orders-api:</strong> 100 %</li><li><strong>Taxa de sucesso dos consumidores do orders-api:</strong> 100 %</li><li><strong>SLO Cumprido:</strong> SIM</li><li><a href="https://github.com/msfidelis/istio-disaster-recovery/tree/main/istio/05-multi-az"><strong>Yaml dos testes executados no cenário</strong></a></li></ul><p>Hipótese validada com sucesso!</p><h3>Considerações finais, e importantes:</h3><ul><li><em>Mecanismo de resiliência é igual itaipava que seu tio trouxe em dia de churrasco: Todo mundo fica bravo de ter que dar espaço na geladeira, no fim todo mundo vai acabar bebendo e sempre vai faltar.</em></li><li>A resiliência a nível de plataforma é uma parte da composição da resiliência de uma aplicação, <strong>não a solução completa pra ela</strong>.</li><li>O fluxo de retry deve ser implementado somente se as aplicações atrás delas tiverem <strong>mecanismos de idempotência</strong> para evitar duplicidades de registros, principalmente, falando em HTTP, de requests que são naturalmente não idempotentes como <strong>POST</strong> por exemplo.</li><li>Os retry e circuit breaker dos meshs em geral <strong>não devem ser tratados como mecanismo de resiliência principal da solução</strong>. Não substitui a resiliência pragmática.</li><li>Não substitui a resiliência a nível de código / aplicação. <em>Repetindo algumas vezes pra fixar</em>.</li><li>Os circuit breakers e retentivas devem ser implementados a nível de código independente da plataforma suportar isso. Procure por soluções como <a href="https://github.com/resilience4j/resilience4j"><strong>Resilience4J</strong></a>, <a href="https://github.com/Netflix/Hystrix"><strong>Hystrix</strong></a>, <a href="https://github.com/sony/gobreaker"><strong>GoBreaker</strong></a>. Só pra constar.</li><li>A busca por circuit breakers pragmáticos tende a prioridade em caso de downtime total de uma dependência, principalmente para buscar fluxos alternativos como fallback, não apenas para serem usados para “<em>dar erro mais rápido</em>”. Pense em “<em>posso ter um SQS como fallback para fazer temporariamente offload para os eventos que eu iria produzir no meu kafka que está com falha?</em>”, “<em>tenho um sistema de apoio para enfileirar as requisições que estão dando falha para processamento tardio</em>”?, “<em>eu posso reprocessar tudo que falhou quando minhas dependências voltarem?</em>” antes de qualquer coisa, beleza?</li></ul><p>Fico por aqui, espero ter ajudado! <a href="https://github.com/msfidelis/istio-disaster-recovery"><strong>Lembrando que todos os arquivos e aplicações estão neste repositório do Github.</strong></a></p><p><strong>Referencias / Material de Apoio:</strong></p><ul><li><strong>Istio Traffic Management</strong> (<a href="https://istio.io/latest/docs/concepts/traffic-management/">https://istio.io/latest/docs/concepts/traffic-management/</a>)</li><li><strong>Istio Traffic Management — Circuit Breaker</strong> (<a href="https://istio.io/latest/docs/tasks/traffic-management/circuit-breaking/">https://istio.io/latest/docs/tasks/traffic-management/circuit-breaking/</a>)</li><li><strong>Envoy — Retry Policy </strong>— <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on">https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on</a></li><li><strong>Chaos Mesh </strong>— <strong>Quickstart</strong> <a href="https://chaos-mesh.org/docs/quick-start/">https://chaos-mesh.org/docs/quick-start/</a></li><li><strong>K6 Loading Testing —</strong> <a href="https://k6.io/docs/getting-started/running-k6/">https://k6.io/docs/getting-started/running-k6/</a></li><li><strong>Setup do EKS com Istio e Terraform</strong> — <a href="https://github.com/msfidelis/eks-with-istio">https://github.com/msfidelis/eks-with-istio</a></li></ul><p><strong>Obrigado aos revisores:</strong></p><ul><li>Rebeca Maia (<a href="https://twitter.com/rebecamaia_p">@ rebecamaia_p</a>)</li><li>Bruno Padilha (<a href="https://twitter.com/brunopadz">@ brunopadz</a>)</li><li>Leandro Grillo (<a href="https://twitter.com/leandrocgrillo">@ leandrocgrillo</a>)</li></ul><p>Me <a href="https://twitter.com/fidelissauro"><strong>sigam no Twitter</strong></a> para acompanhar as paradinhas que eu compartilho por lá!</p><p>Te ajudei de alguma forma? Me pague um café</p><p><strong>Chave Pix:</strong> fe60fe92-ecba-4165-be5a-3dccf8a06bfc</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4fb8469a73da" width="1" height="1" alt="">
