---
layout: post
title: Serverless Framework ⚡️ — Criando (ou migrando) uma REST API com Express.js
  e AWS Lambda.
canonical_url: https://medium.com/@fidelissauro/serverless-framework-%EF%B8%8F-criando-ou-migrando-uma-rest-api-com-express-js-e-aws-lambda-51834740dcdb?source=rss-fc2fda5e9bc2------2
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7NgiewIZzLd180ihdNqBpA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/photos/8KfCR12oeUM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Christopher Burns</a> on <a href="https://unsplash.com/search/photos/builder?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>TL;DR; Esse post é o resultado de alguns labs que tenho feito para suprir algumas demandas de alguns clientes meus, afim de encontrar formas simples e baratas de fazer deploy de aplicações colocando escala, disponibilidade e custo na balança. Para isso iremos migrar uma aplicação construída para rodar em servidores dedicados, ou containers usando <strong>Express.JS</strong> para o <strong>AWS Lambda</strong>, utilizando o <strong>Serverless Framework</strong> com ajuda do plugin <strong>serverless-http, </strong>aproveitando o máximo do negócio e força de trabalho já existente.</p><p>Essa abordagem é um uso do Serverless muito diferente da tradicional, quando pensamos em API’s REST, pensamos em uma função lambda responsável por atender especificamente um endpoint, pra um método HTTP.</p><p>Essa abordagem, vamos criar um proxy resource, no <strong>API Gateway</strong> da <strong>AWS</strong>, e fazer com que apenas uma função lambda seja responsável por atender todas as chamadas da API, independente do recurso ou método solicitado.</p><blockquote>COMO ASSIM???</blockquote><p>Na verdade, vamos aproveitar as rotas de uma aplicação <strong>Express</strong> já existente, vamos pensar nesse post como uma passo a passo pra migração de uma aplicação já fundada para o <strong>Serverless</strong>, aproveitando tudo o que já foi anteriormente construído, toda a arquitetura, os controllers, libraries, configurações e etc.</p><p>As vantagens dessa abordagem</p><ul><li>Custo</li><li>Escala</li><li>Performance</li><li>Deploy</li><li>Validar a ideia de um MVP</li><li>Time to Market</li><li>Onboarding do desenvolvedor</li><li>Capacidade de mudar instantaneamente para servidores ou containers.</li></ul><p>Porém, não é fácil resumir de uma maneira generalista tudo que uma aplicação precisa pra rodar. Portanto, vou levantar alguns dos maiores pontos de dor da maioria das aplicações, e de como conseguimos suprir as demandas dos mesmos com os recursos presentes dentro do <strong>Serverless Framework</strong>, focando é claro, no saudoso Express.</p><ul><li>Rotas</li><li>Deploy</li><li>Replicação</li><li>Variáveis de Ambiente</li></ul><h4>Instalando o Serverless CLI</h4><p>Podemos instalar o CLI do Serverless via modo global via npm.</p><pre>sudo npm install -g serverless</pre><h4>Instalando as dependências do exemplo.</h4><p>Vamos instalar algumas libs normais, que a maioria das aplicações em Express utilizam, e também o <strong>serverless-offline</strong>, para conseguirmos simular nosso ambiente localmente.</p><pre>npm install --save body-parser express helmet cors consign<br>npm install --save-dev serverless-offline</pre><p>Até ai temos dependências normais de uma aplicação Express. Para fazer ele se entender com o proxy do api gateway e responder em conjunto a uma função lambda, precisamos instalar a uma biblioteca chamada serverless-http</p><pre>npm install --save serverless-http</pre><h4>Estrutura de diretórios</h4><p>Nossa estrutura é bem simples. Na verdade, pra esse exemplo só iremos precisar de dois arquivos, o app.js que irá conter as</p><pre>.<br>├── app.js (arquivo de configuração do servidor)<br>├── controllers (pastinha onde vamos armazenar nossos controllers)<br>│   └── pets.js (exemplo de controller)<br>├── handler.js (handler da função lambda)<br>├── package-lock.json<br>├── package.json<br>└── serverless.yml (arquivo de especificações do serverless)</pre><pre>1 directory, 6 files</pre><h4>app.js</h4><p>Esse arquivo irá conter todas as especificações do nosso servidor Express. Assim como fazemos nas aplicações normais. Iremos adicionar o módulo para habilitar CORS, o helmet para aplicar uma camada de segurança nas requisições recebidas, o Body Parser para popularmos o body das nossas requests e o consign, fazendo o require de todos as rotas dentro da pasta controllers .</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cacd7346e82e6daa9cfce6ce99f1720a/href">https://medium.com/media/cacd7346e82e6daa9cfce6ce99f1720a/href</a></iframe><h4>controllers/pets.js</h4><p>Esse é a representação de um controller de uma aplicação qualquer com alguns mocks de respostas. Vamos simular um crud completo.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/17b23d7f2888f87aaf4134982dcd4322/href">https://medium.com/media/17b23d7f2888f87aaf4134982dcd4322/href</a></iframe><h4>handler.js</h4><p>Esse arquivo será o responsável por exportar o event handler do lambda. Basicamente será a função que será executada assim que o lambda for chamado.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1d86a02f083e861f7a5bcff95c1d03bc/href">https://medium.com/media/1d86a02f083e861f7a5bcff95c1d03bc/href</a></iframe><h4>serverless.yml</h4><p>O arquivo serverless.yml é responsável por definir as especificações das funções lambdas, como configurações, providers, limites, triggers, recursos do Cloud Formation a serem criados.</p><p>Diferente da maioria dos exemplos da utilização do Framework, vamos definir um path do API Gateway como um proxy a partir da raiz da API/ , dando um pass through de todos os resources, de todos os métodos. Iremos tratar isso dentro da aplicação. Basicamente estamos dizendo:</p><blockquote>“Hey, API Gateway, todos os recursos, todo o payload, todos os querystrings de qualquer método que chegar ai em você a partir da raiz, manda pra pra nossa lambda aqui. Não pensa muito não.”</blockquote><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/28196ddc8822f8c5f4f5802f20434598/href">https://medium.com/media/28196ddc8822f8c5f4f5802f20434598/href</a></iframe><h4>Testando a Aplicação Local</h4><p>Dentro do nosso arquivo YAML, especificamos o plugin serverless-offline . Esse é um plugin muito bacana e nos fornece um set interessantes de ferramentas para simular várias triggers da AWS localmente.</p><pre>serverless offline start --skipCacheInvalidation</pre><p>O plugin deverá simular um API Gateway, junto com as eventuais demais triggers e invocar as funções lambda correspondentes. Normalmente dentro da porta 3000.</p><pre>Serverless: Starting Offline: v1/us-east-1.</pre><pre>Serverless: Routes for app:<br>Serverless: ANY /<br>Serverless: ANY /{proxy*}</pre><pre>Serverless: Offline listening on <a href="http://localhost:3000"><strong>http://localhost:3000</strong></a></pre><p>Agora vamos executar os testes nos endpoints utilizando o curl</p><pre>curl -X GET <a href="http://localhost:3000/pets">http://localhost:3000/pets</a><br>curl -X POST <a href="http://localhost:3000/pets">http://localhost:3000/pets</a><br>curl -X PUT <a href="http://localhost:3000/pets">http://localhost:3000/pets</a>/1<br>curl -X DELETE <a href="http://localhost:3000/pets">http://localhost:3000/pets</a>/1</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*rZ-_lsuf0Crhl2Pp2_tGzA.png" /></figure><h4>Deploy</h4><p>Vamos executar o mesmo teste que fizemos localmente em produção, mas antes vamos rodar o deploy da aplicação.</p><pre>serverless deploy -v</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BrWl8No397daHD_9nwMh8A.png" /></figure><p>Agora vamos realizar os requests da mesma forma que realizamos localmente, porém com o novo path das API.</p><pre>curl -X GET <a href="https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets">https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets</a><br>curl -X POST <a href="https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets">https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets</a><br>curl -X PUT <a href="https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets">https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets</a>/1<br>curl -X DELETE <a href="https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets">https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets</a>/1</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kqEyNj5xWER0LY4nJP7n5Q.png" /></figure><h4>Variáveis de Ambiente</h4><p>Variáveis de ambiente já são comuns quando se tratamos de AWS Lambda, porém existem algumas limitações. Quando precisamos replicar um ambiente, ou simular o ambiente de produção localmente, precisamos alterar muita coisa. E quando armazenamos senhas, secrets, API Keys nas variáveis de ambiente, acho uma alternativa muito legal utilizar o recurso de variáveis de ambiente do Lambda. Para isso, vamos utilizar uma abordagem que já é comum dentro do ecossistema do Express, o módulo config .</p><p>O modulo config é uma alternativa muito legal pra quem possui vários stages de desenvolvimento. Por default, ele sempre vai procurar arquivos JSON dentro de um diretório chamado config . Ele lê a variável NODE_ENV e procura o arquivo JSON como o nome correspondente a variável. Caso não encontre, ele sempre lê o arquivo default.json .</p><pre>npm install --save config </pre><p>Agora vamos criar o diretório config/ com dois arquivos JSON de configuração, um para desenvolvimento, e outro para produção.</p><pre>mkdir config<br>touch config/{default.json,dev.json}</pre><p>Dessa forma, vamos levar colocar as configurações de produção dentro do arquivo default.json e os de desenvolvimento dentro do dev.json .</p><p><strong>dev.json</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/85b43c6ce857734f4b7a31c657afe809/href">https://medium.com/media/85b43c6ce857734f4b7a31c657afe809/href</a></iframe><p><strong>default.json</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/13e5573cbe96913bc09cf3ce8515ee66/href">https://medium.com/media/13e5573cbe96913bc09cf3ce8515ee66/href</a></iframe><h4>controllers/version.js</h4><p>Agora, vamos criar um controller chamado version.js e adicionar o seguinte endpoint. Ele vai pegar algumas informações dentro do módulo config , que por sua vez vai ser o conteúdo dos arquivos JSON encontrados na nossa pasta de configuração.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ceabacd2de1b0704658b6cef08ebf963/href">https://medium.com/media/ceabacd2de1b0704658b6cef08ebf963/href</a></iframe><p>Dessa forma, nossa estrutura deverá ficar parecida com essa:</p><pre>.<br>├── app.js<br>├── config<br>│   ├── default.json<br>│   └── dev.json<br>├── controllers<br>│   ├── pets.js<br>│   └── version.js<br>├── handler.js<br>├── package-lock.json<br>├── package.json<br>└── serverless.yml</pre><p>Agora vamos testar:</p><p>Executando o serverless offline</p><pre>serverless offline start --skipCacheInvalidation</pre><p>Vamos testar o request</p><pre>curl -X GET <a href="http://localhost:3000/version">http://localhost:3000/version</a></pre><pre>HTTP/1.1 200 OKcontent-type: application/json; charset=utf-8<br>access-control-allow-origin: *<br>x-dns-prefetch-control: off<br>x-frame-options: SAMEORIGIN<br>strict-transport-security: max-age=15552000; includeSubDomains<br>x-download-options: noopen<br>x-content-type-options: nosniff<br>x-xss-protection: 1; mode=block<br>content-length: 38<br>etag: W/&quot;26-eY7T1hNSk9rMb1We4Jgd6trR6jM&quot;<br>vary: origin<br>cache-control: no-cache<br>accept-ranges: bytes<br>Date: Tue, 03 Jul 2018 23:13:32 GMT<br>Connection: keep-alive</pre><pre><strong>{&quot;version&quot;:&quot;1.0.0&quot;,&quot;env&quot;:&quot;Production&quot;}</strong></pre><p>Agora vamos testar de novo, alterando a variável NODE_ENV do nosso runtime.</p><pre>export <strong>NODE_ENV=dev</strong> &amp;&amp; serverless offline start<br> --skipCacheInvalidation</pre><p>Agora vamos testar novamente:</p><pre>curl -X GET <a href="http://localhost:3000/version">http://localhost:3000/version</a> -i</pre><pre>HTTP/1.1 200 OK<br>content-type: application/json; charset=utf-8<br>access-control-allow-origin: *<br>x-dns-prefetch-control: off<br>x-frame-options: SAMEORIGIN<br>strict-transport-security: max-age=15552000; includeSubDomains<br>x-download-options: noopen<br>x-content-type-options: nosniff<br>x-xss-protection: 1; mode=block<br>content-length: 39etag: W/&quot;27-TepRPuPN8rvWIUkb8umQpS4sfUo&quot;<br>vary: origin<br>cache-control: no-cache<br>accept-ranges: bytes<br>Date: Tue, 03 Jul 2018 23:20:07 GMT<br>Connection: keep-alive</pre><pre><strong>{&quot;version&quot;:&quot;1.0.0&quot;,&quot;env&quot;:&quot;Development&quot;}</strong></pre><p>Podemos editar isso no nosso arquivo package.json</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ef004f2cb2a522f88bfe819f6dbdff24/href">https://medium.com/media/ef004f2cb2a522f88bfe819f6dbdff24/href</a></iframe><p>Assim podemos iniciar nosso ambiente de desenvolvimento de forma mais intuitiva.</p><pre>npm run dev</pre><p>Para remover, usamos a mesma forma:</p><pre>serverless remove </pre><p><strong>Fontes:</strong></p><ul><li><a href="https://dev.to/adnanrahic/a-crash-course-on-serverless-apis-with-express-and-mongodb-193k">https://dev.to/adnanrahic/a-crash-course-on-serverless-apis-with-express-and-mongodb-193k</a></li><li><a href="https://serverless.com/blog/serverless-express-rest-api/">https://serverless.com/blog/serverless-express-rest-api/</a></li></ul><p>Espero ter ajudado! 😃</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=51834740dcdb" width="1" height="1" alt="">
