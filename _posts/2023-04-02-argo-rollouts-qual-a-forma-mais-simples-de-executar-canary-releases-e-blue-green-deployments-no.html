---
layout: post
image: https://cdn-images-1.medium.com/max/1024/0*srEMHw3PKt7Ac3_R.png
title: Argo-Rollouts — "Qual a forma mais simples de executar Canary Releases e Blue/Green Deployments no Kubernetes?"
canonical_url: https://medium.com/@fidelissauro/argo-rollouts-qual-a-forma-mais-simples-de-executar-canary-releases-e-blue-green-deployments-no-e030c2ee3af5?source=rss-fc2fda5e9bc2------2
---

<h3>Introdução</h3>
<p>O Deploy em ambientes <strong>Cloud Native</strong> pode ser, se não é, a parte mais desafiadora no dia a dia do
  ciclo de vida de um software, principalmente se a atualização é realizada em aplicações criticas que possuem volumes
  consideráveis de transações.</p>
<p>Nesse contexto, possuímos uma vasta gama de ferramental para gerenciar deployments em ambientes de
  <strong>Kubernetes</strong>, algumas melhores, outras mais modestas e poucas simples e sucintas.</p>
<p>Existe um ponto de atenção muito importante quando falamos de realizar um deploy em produção: <strong>O
    rollback</strong>.</p>
<p>Uma frase simples, mas que mudou minha forma de pensar sobre qualquer coisa que eu colocaria a mão quando trato desse
  tema veio do meu mestre <a href="https://twitter.com/fernandoike"><strong>Fernando Ike</strong></a>. <strong><em>“Mais
      importante que entregar rápido, é voltar rápido” </em></strong>— Algo assim.</p>
<p>Nesses dias um colega de trabalho me fez uma pergunta que me deixou pensativo das ideia, e que pra responder de forma
  decente, prometi escrever esse artigo:</p>
<p>&gt; <strong><em>“Qual a forma mais simples de executar um Canary ou um Blue Green no Kubernetes?”</em></strong></p>
<p>Executar <strong>Canary</strong> e <strong>Blue / Green</strong> eu conheço algumas formas de fazer. Provavelmente
  você também. Experiência com ferramentas, truques no kubectl e tudo mais não falta por ai. Mas beleza, mas qual das
  várias possibilidades é a mais simples?</p>
<h3>O Argo Rollouts</h3>
<p>O <strong>Argo Rollouts</strong> é uma ferramenta de automação de implantação em clusters <strong>Kubernetes</strong>
  que fornece recursos avançados de controle de versão. Ele é projetado para ajudar os desenvolvedores a gerenciar o
  ciclo de vida de seus aplicativos de maneira mais eficiente e confiável, permitindo que eles implantem novas versões
  de aplicativos com mais segurança e menos tempo de inatividade. E antes de tudo, de forma simples.</p>
<p>O <strong>Argo Rollouts</strong> é uma extensão do <strong>Argo CD</strong>, outra ferramenta popular de automação de
  implantação de <strong>Kubernetes</strong>. Ele é construído em cima do controlador de implantação nativo do
  <strong>Kubernetes</strong> e é compatível com várias plataformas em nuvem, incluindo <strong>AWS</strong>,
  <strong>Google Cloud</strong> e M<strong>icrosoft Azure.</strong></p>
<p>O <strong>Argo CD</strong> é talvez a ferramenta favorita da maioria das pessoas, eu tento não ser fã de tooling, mas
  provavelmente é a minha também. Porém, não é simples.As vezes precisamos dar um simples upgrade do que já temos
  nativamente pra resolver a maioria dos problemas. O <strong>Argo-Rollouts </strong>talvez tenha sido uma resposta
  a isso.</p>
<h3>Premissas</h3>
<p>A proposta desse post é mostrar o funcionamento básico do Argo-Rollouts resolvendo problemas reais, de forma que
  consiga ser adaptado ao maior numero de contextos possíveis.</p>
<p>Com excessão do argo-rollouts, não vou focar em nenhuma outra ferramenta que por ventura possa aparecer nesse post.
</p>
<p>Todas as possíveis soluções para os problemas apresentados serão apresentados de duas formas:</p>
<ul>
  <li>Os exemplos desse artigo serão apresentados em forma de perguntas ou requisitos hipotéticos, seguido da
    implementação que resolveria a questão. Gosto desse tipo de abordagem.</li>
  <li>Utilizarei o modo mais “manual” possível para que as logicas possam ser reaproveitados de forma genérica em
    qualquer tipo de orquestrador de pipelines que eventualmente faça entregas de software num cluster Kubernetes.</li>
  <li>No final apresentando um componente adicional, da dashboard do argo-rollouts, que pode ser um grande aliado na
    hora de separar os processos de CI/CD e deixar a progressão dos deploys mais customizáveis e cautelosos.</li>
</ul>
<h3>Instalação do Kubectl Plugin</h3>
<p>A arquitetura de manipulação do <strong>Argo Rollouts</strong> funciona primeiramente como um<strong> client
    / server.</strong></p>
<p>Basicamente, caso você não escreva passos de deployment que se viram sozinhos, baseados em tempo e etc, você
  precisara utilizar o plugin do kubectl para o rollouts para promover, abortar ou dar rollback de versões. Então
  entende-se que esse plugin precisa estar instalado no seu orquestrador de pipelines caso necessite gerenciar o ciclo
  dessa forma.</p>
<p>A instalação, siga as <strong>Installation Guide</strong> oficial do Argo Rollouts.</p>
<p><a href="https://argoproj.github.io/argo-rollouts/installation/">Installation - Argo Rollouts - Kubernetes
    Progressive Delivery Controller</a></p>
<h3>Instalação do Argo-Rollouts</h3>
<p>A instalação da ferramenta possui algumas alternativas, mas nesse post iremos abordar o método via Helm. Para as
  demais, você pode acessar o manual de instalação.</p>
<h3>Instalação via Helm</h3>
<p>A instalação via helm é bem simples e sem segredo.</p>
<pre>helm repo add argo &lt;https://argoproj.github.io/argo-helm&gt;<br>helm install argo-rollouts argo/argo-rollouts</pre>
<p>Para a instalação da Dashboard, será necessário adicionar o parâmetro --set dashboard.enabled=true</p>
<pre>helm install argo-rollouts argo/argo-rollouts --set dashboard.enabled=true</pre>
<h3>Instalação do Helm via Terraform</h3>
<p>Uma opção interessante também é utilizar o provider do helm para o terraform. Como já abordamos esses processo em
  alguns outros artigos, vou deixar o exemplo aqui também. Certeza que vai ser útil em algum momento pra alguém.</p>
<pre>resource &quot;helm_release&quot; &quot;argo_rollouts&quot; {<br>    <br>    name                = &quot;argo-rollouts&quot;<br>    chart               = &quot;argo-rollouts&quot;<br>    repository          = &quot;&lt;https://argoproj.github.io/argo-helm&gt;&quot;<br>    namespace           = &quot;argo-rollouts&quot;<br>    create_namespace    = true<br><br>    set {<br>            name = &quot;dashboard.enabled&quot;<br>            value = true<br>        }<br>}</pre>
<h3>Estrutura de um Rollout</h3>
<p>Uma coisa que precisa ficar evidente, na lata, quando começamos a utilizar o <strong>Argo-Rollouts</strong>, é que
  vamos <strong>parar de utilizar</strong> os manifestos de Deployment. Isso é a premissa inicial da ferramenta, mas
  calma. É muito simples.</p>
<p>No lugar do que escreveriamos nossos pod templates e replicas, no Deployment vamos começar a utilizar o objeto
  Rollout , disponível a partir dos CRD&#39;s do Argo Rollouts no lugar.</p>
<p>De forma genérica, migrariamos um Deployment convencional que já estamos acostumados disso:</p>
<pre>apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  name: nginx-deployment<br>spec:<br>  selector:<br>    matchLabels:<br>      app: nginx<br>  replicas: 10 <br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      containers:<br>      - name: nginx<br>        image: nginx:1.14.2<br>        ports:<br>        - name: http<br>          containerPort: 80<br>          protocol: TCP</pre>
<p>Para algo parecido com o item abaixo, onde temos a mesma estrutura de template/spec para os pods, porém adicionamos o
  campo strategy onde vamos descrever como será executado os rollouts de versão. Não se atente a esse modelo agora,
  vamos evoluir bastante o case a seguir.</p>
<pre>apiVersion: argoproj.io/v1alpha1<br>kind: Rollout<br>metadata:<br>  name: nginx-deployment<br>spec:<br>  replicas: 10<br>  revisionHistoryLimit: 2<br>  selector:<br>    matchLabels:<br>      app: nginx<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      containers:<br>      - name: nginx<br>        image: nginx:1.14.2<br>        ports:<br>        - name: http<br>          containerPort: 80<br>          protocol: TCP<br>  strategy:<br>    canary:<br>      steps:<br>      - setWeight: 20<br>      - pause: {duration: 30}<br>      - setWeight: 50<br>      - pause: {duration: 60}<br>      - setWeight: 80<br>      - pause: {}</pre>
<h3>Canary Release</h3>
<p>O <strong>Canary Deployment</strong> é um padrão de deploy onde uma nova versão de uma aplicação é implantada em uma
  quantidade determinada e progressiva de instâncias para fins de teste e validação a quente antes de ser totalmente
  implantada em todo o ambiente de produção.</p>
<p>Esse processo também é conhecido sem estrangeirismo como <strong>Canário</strong>. Durante o período de teste,
  <strong>o tráfego é direcionado para o canário, permitindo que a nova versão do aplicativo seja validada em um
    ambiente real, mas com um menor risco de interrupção</strong> para o restante dos usuários,<strong> recebendo uma
    quantidade pequena, porém progressiva, do tráfego</strong> até que seja promovida a versão estável.</p>
<p><strong>O ideal, é que se houver algum problema durante os testes, a implantação do canário pode ser revertida com
    facilidade, minimizando o impacto para o restante dos usuários.</strong></p>
<p>Os <strong>Canary Deployments</strong> são amplamente utilizados em ambientes de produção, especialmente em
  implantações críticas em que os erros podem ter consequências graves, ou onde <strong>queremos validar um de-para a
    quente de alguma feature</strong>, modificação, migração. Essa técnica ajuda a garantir a estabilidade e a qualidade
  do aplicativo, ao mesmo tempo em que permite que as equipes de desenvolvimento e operações <strong>realizem testes e
    validações com segurança junto ao tráfego real</strong>.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/360/1*tcqTyqa0QHGtwrbMphOc0A.gif" /></figure>
<p>Tentei elaborar mentalmente alguns requisitos de plataforma nos quais o Canary Release proposto pelo <strong>Argo
    Rollouts</strong> resolveria.</p>
<h4>&quot;Eu preciso que meu canário progrida automaticamente 20% a cada 30 segundos sozinho, de depois promova
  a versão&quot;</h4>
<p>Essa talvez seja a abordagem inicial dos espectros do canary automatizado. Temos alguns time-boxes que podem variar
  de segundos, minutos, horas ou dias e queremos que a progressão da porcentagem do uso progrida dentro desses
  intervalos. Tudo dependendo do nível de exigência e criticidade da aplicação ou o quão específica e crítica aquela
  mudança pode ser em relação ao todo.</p>
<p>Então para este primeiro cenário, vamos aplicar o seguinte manifesto, adicionando vários steps com o peso desejado da
  porcentagem do rollout e informando as pausas desejadas para cada uma das progressões de carga.</p>
<pre>---<br>apiVersion: argoproj.io/v1alpha1<br>kind: Rollout<br>metadata:<br>  name: chip<br>  namespace: chip<br>spec:<br>  replicas: 10<br>  strategy:<br>    canary:<br>      steps:<br>      - setWeight: 20<br>      - pause: {duration: 10}<br>      - setWeight: 40<br>      - pause: {duration: 10}<br>      - setWeight: 60<br>      - pause: {duration: 10}<br>      - setWeight: 80<br>      - pause: {duration: 10}<br>      - setWeight: 100    <br>  revisionHistoryLimit: 2<br>  selector:<br>    matchLabels:<br>      app: chip</pre>
<p>Para acompanhar os rollouts localmente, vamos utilizar a função watch do plugin do argo que instalamos no kubectl,
  onde podemos acompanhar a devida progressão dos pods entre as duas versões.</p>
<pre>kubectl argo rollouts get rollout chip -n chip --watch</pre>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5QYh21jVsmbiPI-hnPp99Q.png" /></figure>
<p>Para ilustrar, na imagem abaixo tem um loop de consumo de uma API que retorna a devida versão da mesma. Assim podemos
  acompanhar visualmente como funciona a progressão a quente para os consumidores do serviço em questão. Vamos usar essa
  abordagem a partir daqui.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*SLN877naES-VpjuZTo3wJg.png" /></figure>
<p>Após todos os steps finalizarem, teremos nossa revision:2marcada como stable e a revision:1 descontinuada. Porém ela
  vai ficar ali podendo ser reativada num possível rollback. Trataremos disso mais pra frente.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*u5b1Lc6AlPtr4VzpsswUVw.png" /></figure>
<p>Visualmente, durante nossas interações com as requisições que retornam a versão da aplicação de teste, podemos ver
  ela totalmente promovida:</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LRHFBPBs7WqJSXCeTrnkvA.png" /></figure>
<p><a href="https://github.com/msfidelis/argo-rollouts-article/blob/main/canary/canary-auto-progressive.yml"><strong>Exemplo
      completo — Github</strong></a></p>
<h4>“Eu preciso que meu canário progrida sozinho até 80%, porém eu gostaria de promover ou abortar o restante
  manualmente”</h4>
<p>Um outro tipo de cenário de uso é uma progressão gradual controlada, porém que seja necessária uma intervenção humana
  para progressão da release em si. Nesse cenário hipotético, vamos imaginar que eu gostaria que a progressão funcione
  como o primeiro exemplo, de x em x tempo, porém pare em 80%. E a partir daí, alguém aprova ou aborta a mudança
  de versão.</p>
<pre>---<br>apiVersion: argoproj.io/v1alpha1<br>kind: Rollout<br>metadata:<br>  name: chip<br>  namespace: chip<br>spec:<br>  replicas: 10<br>  strategy:<br>    canary:<br>      steps:<br>      - setWeight: 20<br>      - pause: {duration: 10}<br>      - setWeight: 60<br>      - pause: {duration: 10}<br>      - setWeight: 80<br>      - pause: {}  <br>  revisionHistoryLimit: 2<br>  selector:<br>    matchLabels:<br>//...</pre>
<p>Nesse caso, temos a opção de colocar uma instrução de pause sem uma duração definida, e nosso rollout entrará num
  status de Paused indefinidademente quando chegar no step. Nesse caso em especifico, precisaremos dar uma instrução
  para o argo manualmente continuar o rollout, ou abortá-lo e retornar a versão anterior.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LkFudHsvWPSvLOzw95TRdA.png" /></figure>
<p>Essas instruções são os comandos promote e abort também vindos do plugin do Argo Rollouts. O promote irá progredir o
  step atual, o abort irá cancelar o rollout e retornar todos os pods da aplicação para a versão anterior.</p>
<p>Um adendo ao abort é que ele pode ser executado em qualquer momento do ciclo de vida do rollout.</p>
<pre>kubectl argo rollouts promote chip -n chip</pre>
<pre>kubectl argo rollouts abort chip -n chip</pre>
<p><a href="https://github.com/msfidelis/argo-rollouts-article/blob/main/canary/canary-final-promote.yml"><strong>Exemplo
      Completo — Github</strong></a></p>
<h4>“Eu preciso que meu canário progrida até 20%, depois necessite de uma intervenção manual para continuar o rollout”
</h4>
<p>Esse processo é exatamente igual ao anterior, porém vamos pensar num case onde eu queria ser um pouco mais
  conservador e chato quanto ao meu rollout, e queria promover uma pequena porcentagem para o meu canary, olhar minha
  observability, acompanhar com mais calma antes de prosseguir com o rollout automatizado. Nesse caso somente precisamos
  adicionar o step pause depois de promover a primeira porcentagem. Assim precisaremos dar o promote para prosseguir, ou
  o abort logo de começo.</p>
<pre>---<br>apiVersion: argoproj.io/v1alpha1<br>kind: Rollout<br>metadata:<br>  name: chip<br>  namespace: chip<br>spec:<br>  replicas: 10<br>  strategy:<br>    canary:<br>      steps:<br>      - setWeight: 20<br>      - pause: {}<br>      - setWeight: 40<br>      - pause: {duration: 10}<br>      - setWeight: 60<br>      - pause: {duration: 10}<br>      - setWeight: 80<br>      - pause: {duration: 10}<br>      - setWeight: 100      <br>  revisionHistoryLimit: 2<br>  selector:<br>    matchLabels:<br>//...</pre>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hOONNhP8CjNjtG24F5CChw.png" /></figure>
<pre>kubectl argo rollouts promote chip -n chip</pre>
<p>Uma abordagem que deriva dessa é fazer o inverso, promover automaticamente até uma porcentagem menor, e pedir uma
  intervenção manual para progredir automaticamente até a estabilização da versão.</p>
<p><a href="https://github.com/msfidelis/argo-rollouts-article/blob/main/canary/canary-initial-promote.yml"><strong>Exemplo
      Completo — Github</strong></a></p>
<h4>&quot;Eu gostaria que meu canário tivesse passos de 10 em 10%, mas que eu consiga promover todos manualmente&quot;
</h4>
<p>Pra uma abordagem mais conservadora e crítica, é possível que os rollouts aconteçam de forma contínua com baixa
  progressão de volume, em que cada step seja promovido manualmente.</p>
<p>Esse cenário é interessante pra produtos que sejam extremamente sensíveis a falhas com volumes altos de clientes e
  que possam gerar prejuízos grandes em casos de erro. Em todo caso, uma abordagem mais cuidadosa.</p>
<p>Imagine nesse cenário acima, você está trocando a API de um fornecedor, fez alguma melhoria de performance, trocou um
  flavor de banco, algum driver, atualizou versão de framework e etc, e gostaria que esse rollout acontecesse de forma
  extremamente validada.</p>
<p>Nesse caso, vamos utilizar o step pause em seguida de cada progressão de porcentagem do rollout, sem as definições de
  duration. Nesse sentido em cada promoção de step, o argo vai pausar a progressão, sendo necessária a intervenção
  manual em cada um deles.</p>
<pre>---<br>apiVersion: argoproj.io/v1alpha1<br>kind: Rollout<br>metadata:<br>  name: chip<br>  namespace: chip<br>spec:<br>  replicas: 10<br>  strategy:<br>    canary:<br>      steps:<br>      - setWeight: 10<br>      - pause: {}<br>      - setWeight: 20<br>      - pause: {}<br>      - setWeight: 30<br>      - pause: {}<br>      - setWeight: 40<br>      - pause: {}<br>      - setWeight: 50<br>      - pause: {}<br>      - setWeight: 60<br>      - pause: {}<br>      - setWeight: 70<br>      - pause: {}<br>      - setWeight: 80<br>      - pause: {}<br>      - setWeight: 90<br>      - pause: {}<br>      - setWeight: 100<br>  revisionHistoryLimit: 2<br>  selector:<br>    matchLabels:<br><br>// ...</pre>
<p>Em cada uma das pausas dos steps, vamos precisar executar o comando de promote</p>
<pre>kubectl argo rollouts promote chip -n chip // (x10)</pre>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hhT_t5ClhNZ97QfUJwgU-g.png" /></figure>
<p><a href="https://github.com/msfidelis/argo-rollouts-article/blob/main/canary/canary-step-promotion.yml"><strong>Exemplo
      Completo — Github</strong></a></p>
<h3>Blue / Green Deployments</h3>
<p>O <strong>Blue/Green Deployment</strong>, é diferente do <strong>Canary</strong> em sua concepção, no qual cumpre o
  objetivo de realizar uma validação prévia do deploy. <strong>A diferença para o canary, é que a a nova versão do
    aplicativo é implantada em paralelo ao ambiente de produção atual (ambiente Blue), sem afetar o tráfego do usuário
    da versão estável (ambiente Green)</strong>, porém é configurada uma rota customizada para que seja possível
  realizar testes durante o processo de deploy antes de promover a versão nova.</p>
<p>A estratégia <strong>Blue/Green Deployment </strong>é comumente usada em ambientes de alta disponibilidade, onde
  interrupções ou erros no ambiente de produção podem ter um grande impacto na experiência do usuário, basicamente
  <strong>é a melhor opção onde a aplicação é muito sensível a erros no geral</strong>. Essa técnica tem muito a agregar
  na maior parte do tempo, porém é considerada um pouco mais cara, e não permite fazer uma validação gradual de uma
  feature com o cliente real, por exemplo.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/611/1*k0d5ugLsZ76poUtbAfoUHQ.gif" /></figure>
<h4>Configuração Inicial do Service para o Blue/Green</h4>
<p>Diferente do modelo do canary que utiliza o mesmo Service precisamos de antemão criar 2 services, um que vai
  representar a versão active e outra que funcionará como a versão preview , ou trazendo pro termo genérico um será a
  versão blue e outra será a versão green.</p>
<pre>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: chip-active<br>  namespace: chip <br>  labels:<br>    app.kubernetes.io/name: chip<br>    app.kubernetes.io/instance: chip <br>spec:<br>  ports:<br>  - name: web<br>    port: 8080<br>    protocol: TCP<br>  selector:<br>    app: chip<br>  type: ClusterIP<br></pre>
<pre>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: chip-preview<br>  namespace: chip   <br>  labels:<br>    app.kubernetes.io/name: chip<br>    app.kubernetes.io/instance: chip <br>spec:<br>  ports:<br>  - name: web<br>    port: 8080<br>    protocol: TCP<br>  selector:<br>    app: chip<br>  type: ClusterIP<br>---</pre>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ffmwP6LRX5I6mKjeqS6mhQ.png" /></figure>
<p>Também será necessário criar <strong>duas rotas no seu ingress</strong>, uma para validação no seu
  <strong>preview</strong> e outra para a versão <strong>ativa</strong>, algo parecido. No Istio, teriamos algo parecido
  com isso:</p>
<pre>---<br>apiVersion: networking.istio.io/v1alpha3<br>kind: Gateway<br>metadata:<br>  name: chip-gateway<br>  namespace: chip<br>spec:<br>  selector:<br>    istio: ingressgateway <br>  servers:<br>  - port:<br>      number: 80<br>      name: http<br>      protocol: HTTP<br>    hosts:<br>    - &quot;chip.k8s.raj.ninja&quot;<br>---<br>apiVersion: networking.istio.io/v1alpha3<br>kind: Gateway<br>metadata:<br>  name: chip-gateway-preview<br>  namespace: chip<br>spec:<br>  selector:<br>    istio: ingressgateway <br>  servers:<br>  - port:<br>      number: 80<br>      name: http<br>      protocol: HTTP<br>    hosts:<br>    - &quot;chip-preview.k8s.raj.ninja&quot;</pre>
<h4>“Eu gostaria de ter a capacidade de validar minha versão Green através de uma rota específica, e promover
  manualmente”</h4>
<p>Escrevendo nosso rollout de <strong>blue/green</strong>, precisamos parametrizar inicialmente o activeService e o
  previewService de forma com que nosso rollout saiba quais services controlar durante as viradas de cargas e validação.
</p>
<p>E como a proposta desse cenário é validar e promover manualmente depois de certas validações, importante setar o
  parâmetro autoPromotionEnabled como false.</p>
<pre>---<br>apiVersion: argoproj.io/v1alpha1<br>kind: Rollout<br>metadata:<br>  name: chip<br>  namespace: chip<br>spec:<br>  replicas: 10<br>  strategy:<br>    blueGreen: <br>      activeService: chip-active<br>      previewService: chip-preview<br>      autoPromotionEnabled: false<br>  revisionHistoryLimit: 2<br>  selector:<br>    matchLabels:<br>      app: chip<br>  template:<br>//...</pre>
<p>Aplicando uma versão nova, o argo irá manter as duas versões, no mesmo capacity, uma do lado da outra esperando.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*soutJkhPms5-q9VPZp2tYw.png" /></figure>
<p>A configuração do seu ingress deverá permitir o acesso as versões da seguinte forma, seja ela realizada por header,
  path, host ou qualquer outra coisa.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5FAp5ceaE7E8d1xFjue90g.png" /></figure>
<p>Vamos criar um looping para o consumo em paralelo das duas versões da API para acompanhar a virada da versão.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nvr4T2jpKlyyDpfkve1nPg.png" /></figure>
<p>Tendo os comportamento validados, podemos promover da seguinte forma:</p>
<pre>kubectl argo rollouts promote chip -n chip</pre>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*W3X3pHr-e019T-qtk4jSAg.png" /></figure>
<p>Agora aguardaremos até a versão revision:2 estabilizar.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_xnSKI8PAR8o-DU6S1qGaw.png" /></figure>
<p><a
    href="https://github.com/msfidelis/argo-rollouts-article/blob/main/blue-green/blue-green-manual-promote.yml"><strong>Exemplo
      Completo — Github</strong></a></p>
<h4>&quot;Eu gostaria de que minha versão de preview recebesse alguns requests para warm up do meu runtime ou realizar
  testes antes de promover para a versão ativa&quot;</h4>
<p>O interessante do Blue Green é que ele trabalhe de forma com que você consiga validar o comportamento da sua versão
  nova manualmente, por processos automatizados, ferramentas de teste antes de promover a versão nova para o
  cliente final.</p>
<p>Neste cenário irei realizar uma ferramente de <strong>HTTP Bench</strong> para realizar um numero considerável de
  requests para minha versão nova afim de simular um “<strong><em>warm up</em></strong>” do runtime. <strong>Esse
    processo pode ser interessante para workloads criados em JVM que precisam de uma “esquentada” nos primeiros
    instantes de vida para performar da melhor forma</strong>.</p>
<p>Uma ideia interessante é utilizar seus testes de fumaça de forma containerizada, subir seu roteiro num container e
  executá-lo da mesma forma.</p>
<p>Precisamos criar um AnalysisTemplate descrevendo que tipo de análise vamos realizar para dar uma flag na nossa
  versão. Nesse caso vou executar um container do cassowary em uma rota qualquer do meu serviço, simulando um endpoint
  de verdade que precise desse tipo de estratégia:</p>
<pre>---<br>kind: AnalysisTemplate<br>apiVersion: argoproj.io/v1alpha1<br>metadata:<br>  name: chip-http-warm-up<br>  namespace: chip<br>spec:<br>  metrics:<br>  - name: http-bench-analysis<br>    failureLimit: 1<br>    provider:<br>      job:<br>        spec:<br>          backoffLimit: 1<br>          template:<br>            metadata:<br>              labels:<br>                istio-injection: disabled<br>                sidecar.istio.io/inject: &quot;false&quot;<br>            spec:<br>              containers:<br>              - name: http-bench-analysis<br>                image: rogerw/cassowary:v0.14.0<br>                command: [&quot;cassowary&quot;]<br>                args: [&quot;run&quot;, &quot;-u&quot;, &quot;&lt;http://chip-preview.chip.svc.cluster.local:8080/healthcheck&gt;&quot;, &quot;-c&quot;, &quot;3&quot;, &quot;-n&quot;, &quot;1000&quot;]<br>              restartPolicy: Never<br>    count: 1<br>---</pre>
<p>Agora no nosso rollout, vamos utilizar o prePromotionAnalysis passando o nosso AnalysisTemplate criado</p>
<pre>---<br>apiVersion: argoproj.io/v1alpha1<br>kind: Rollout<br>metadata:<br>  name: chip<br>  namespace: chip<br>spec:<br>  replicas: 10<br>  strategy:<br>    blueGreen: <br>      activeService: chip-active<br>      previewService: chip-preview<br>      autoPromotionEnabled: false<br>      prePromotionAnalysis:<br>        templates:<br>        - templateName: chip-http-warm-up<br>  revisionHistoryLimit: 2<br>  selector:<br>    matchLabels:<br>// ...</pre>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IGunLxEntRZjAf3HKM62Rw.png" /></figure>
<p>Podemos validar o seguinte cenário coletando algumas métricas dos dois services. Também é uma boa prática acompanhar
  as duas versões em paralelo no momento de um rollout. Nesse caso, podemos ver um pico de requisições acontecendo no
  service preview conforme parametrizado no AnalysisTemplate.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JJ7nGOb7LYlQ8X3yrUQNsQ.png" /></figure>
<p>Agora que já temos nosso warm up finalizado, vamos promover nosso rollout com nossos hipotéticos runtimes warmados
  para receber o tráfego real.</p>
<pre>kubectl argo rollouts promote chip -n chip</pre>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*STUTJ3kuVkDbu4IrNAaVPA.png" /></figure>
<p><a href="https://github.com/msfidelis/argo-rollouts-article/blob/main/blue-green/blue-green-pre-warm-up.yml"><strong>Exemplo
      Completo — Github</strong></a></p>
<h4>“Preciso executar uma bateria de testes na minha versão de preview, e criar uma análise de métricas automatizada
  para validar se a versão está saudável. É possível?”</h4>
<p>Sim, assim como podemos criar um <strong>AnalysisTemplate</strong> pra executar os testes, podemos criar outro em
  seguida que a partir de métricas do Prometheus, consegue dar um sinal verde ou vermelho pra nossa aplicação finalizar
  o rollout. Nesse caso seria interessantes tanto o <strong><em>autoPromote: false</em></strong> como o
  <strong><em>autoPromote: true</em></strong> para workloads que tenham mais confiança.</p>
<p>Vamos reaproveitar o <strong>AnalysisTemplate</strong> do exemplo anterior nesse aqui como uma continuidade.</p>
<p>Além dele vamos criar um outro template onde vamos definir uma query <strong>PromQL</strong> que será executada em
  uma instância de prometheus que esteja agregando as métricas do nosso cluster.</p>
<p>Para isso vamos precisar configurar algumas coisas, sendo elas o provider do prometheus onde vamos informar a URL do
  Prometheus, nesse caso tenho uma instancia rondando no meu cluster então informarei a URL do service.</p>
<p>Em seguida vamos definir qual será a query de consulta. No caso do exemplo estou fazendo um calculo de
  <strong>SLO</strong> de disponibilidade avaliando os 5 ultimos minutos.</p>
<p>Por ultimo vamos informar o successRate onde vamos colocar uma condição do teste ser aceito ou não.</p>
<pre>---<br>apiVersion: argoproj.io/v1alpha1<br>kind: AnalysisTemplate<br>metadata:<br>  name: chip-error-rate-check<br>  namespace: chip<br>spec:<br>  metrics:<br>  - name: success-rate<br>    interval: 2m<br>    successCondition: result[0] &gt;= 0.95<br>    failureLimit: 1<br>    provider:<br>      prometheus:<br>        address: &lt;http://prometheus.istio-system.svc.cluster.local:9090&gt;<br>        query: |<br>          sum(irate(<br>            istio_requests_total{destination_service=~&quot;chip-preview.chip.svc.cluster.local&quot;,response_code!~&quot;5.*&quot;}[5m]<br>          )) /<br>          sum(irate(<br>            istio_requests_total{destination_service=~&quot;chip-preview.chip.svc.cluster.local&quot;}[5m]<br>          ))<br>    count: 1          <br>---</pre>
<p>Como no exemplo anterior, adicionar apenas mais um step após o nosso <strong><em>“smoke test”</em></strong>
  availiando as métricas de disponibilidade do mesmo:</p>
<pre>---<br>apiVersion: argoproj.io/v1alpha1<br>kind: Rollout<br>metadata:<br>  name: chip<br>  namespace: chip<br>spec:<br>  replicas: 10<br>  strategy:<br>    blueGreen: <br>      activeService: chip-active<br>      previewService: chip-preview<br>      autoPromotionEnabled: false<br>      prePromotionAnalysis:<br>        templates:<br>        - templateName: chip-http-warm-up<br>        - templateName: chip-error-rate-check<br>  revisionHistoryLimit: 2<br>  selector:<br>    matchLabels:<br>      app: chip<br>  template:<br>    metadata:<br>//...</pre>
<p>Aplicando iremos ver correr o blue/green como já estamos acostumados, porém com um adicional no qual iremos ver
  rodando os AnalysisTemplates, um que vai executar nossos testes / warm up e o do Prometheus que irá sumarizar as
  métricas do teste.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7miYjtv-yKivNl7b0QUf5Q.png" /></figure>
<p>Para maiores informações a respeitos das análises que fazemos através dos templates, podemos verificar os objetos
  AnalysisRun</p>
<pre>kubectl get analysisrun -n chip<br>kubectl describe analysisrun &lt;id&gt; -n chip</pre>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BOWwgv5nyi9_x07tTXNO1Q.png" /></figure>
<p><a
    href="https://github.com/msfidelis/argo-rollouts-article/blob/main/blue-green/blue-green-prometheus-analysis-auto.yml"><strong>Exemplo
      Completo — Github</strong></a></p>
<h3>Rollbacks de Versões Anteriores</h3>
<p>É uma premissa do canary que seja possível validar a nova versão aos poucos e a partir do trafego do cliente
  conseguir validar o sucesso de uma implantação. Esse sucesso pode ser medido de diversas formas, a olho nú ou de
  formas automatizadas como pudemos ver nesse artigo.</p>
<p>Mas independente do modelo de deployment aplicado no no produto, é muito importante que existam ferramentas que
  possibilitem alternativas de rollback de forma rápida. Repetindo mais uma vez: <strong><em>&quot;Melhor que entregar
      rápido, é voltar rápido&quot;</em></strong></p>
<p>Vamos imaginar um cenário hipotético em que uma release de canário começou a ser promovida e durante os steps,
  podemos identificar que uma taxa de erros incomum começou a subir junto a progressão dos steps.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*l8Y9zbrzrTU85IFnlRQ8uw.png" /></figure>
<p>Como já vimos, existe a opção abort para reverter um rollout durante sua execução, podendo ser executado a
  qualquer momento.</p>
<pre>kubectl argo rollouts abort chip -n chip;</pre>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ON6fbKMuy_og9Gndqsi-sA.png" /></figure>
<p>Já vimos essa dinâmica antes, mas fui um pouco repetitivo propostivalmente para mostrar uma alternativa pra quando a
  versão com erro já foi promovida e estabilizada e será necessário um rollback.</p>
<h4>“Mesmo com o canário ou blue/green, eu comi bola e por um comportamento não previsto, preciso voltar a versão
  anterior rápido”</h4>
<p>O comando de abort pode ser executado em qualquer momento do ciclo de vida de implementação do Rollout, porém quando
  a versão é promovida para stable o processo é um pouco diferente.</p>
<p>Depois de uma implantação finalizada, é necessário o rollout de uma versão anterior do zero, nesse caso iremos
  utilizar o comando… pasmem, chamado rollback.</p>
<p>Após o inicio do rollback será realizado um rollout novo, promovendo a versão anterior.</p>
<pre>kubectl argo rollouts rollback chip -n chip;</pre>
<p>Tanto no caso anterior do abort quando nessa do rollback o resultado final de uma implantação que teve um plano de
  retorno deverá ser parecida com a abaixo, onde a taxa de erro anômala identificada retorna aos níveis normais da
  aplicação.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hRJMhCSA6LOBOeChbf7oHw.png" /></figure>
<h3>Horizontal Pod Autoscaler / Vertical Pod Autoscaler</h3>
<p>Agora vamos para algumas dicas úteis pra resolver alguns problemas que você venha a encontrar durante seus testes e
  migração do Argo. Caso você esteja utilizando <strong>HPA/VPA</strong> em seu workload, será necessário fazer algumas
  modificações no objeto do HorizontalPodAutoscaler e VerticalPodAutoscaler alterando o scaleTargetRef trocando o
  apiVersion de apps/v1 para [argoproj.io/v1alpha1](&lt;http://argoproj.io/v1alpha1&gt;) e o Kind de Deployment para
  Rollout , assim conseguimos acertar as referencias.</p>
<pre>---<br>apiVersion: autoscaling/v2beta2<br>kind: HorizontalPodAutoscaler<br>metadata:<br>  name: chip<br>  namespace: chip<br>spec:<br>  maxReplicas: 10<br>  minReplicas: 10<br>  metrics:<br>    - type: Resource<br>      resource:<br>        name: cpu<br>        target:<br>          type: Utilization<br>          averageUtilization: 60<br>  scaleTargetRef:<br>    apiVersion: apps/v1<br>    kind: Deployment<br>    name: chip<br>---</pre>
<p>Para isso</p>
<pre>---<br>apiVersion: autoscaling/v2beta2<br>kind: HorizontalPodAutoscaler<br>metadata:<br>  name: chip<br>  namespace: chip<br>spec:<br>  maxReplicas: 10<br>  minReplicas: 10<br>  metrics:<br>    - type: Resource<br>      resource:<br>        name: cpu<br>        target:<br>          type: Utilization<br>          averageUtilization: 60<br>  scaleTargetRef:<br>    apiVersion: argoproj.io/v1alpha1<br>    kind: Rollout<br>    name: chip<br>---</pre>
<h3>Dashboard, uma alternativa mais amigável para acompanhamento dos rollouts.</h3>
<p>Para acessar a dashboard será necessário também expor o pod argo-rollouts-dashboard no seu ingress. Como no caso
  estou utilizando Istio, o exemplo seria esse:</p>
<pre>---<br>apiVersion: networking.istio.io/v1alpha3<br>kind: Gateway<br>metadata:<br>  name: argo-dashboard<br>  namespace: argo-rollouts<br>spec:<br>  selector:<br>    istio: ingressgateway <br>  servers:<br>  - port:<br>      number: 80<br>      name: http<br>      protocol: HTTP<br>    hosts:<br>    - &quot;argo-rollouts-dashboard&quot;<br>    - &quot;dashboard-argo.k8s.raj.ninja&quot;<br>---<br>apiVersion: networking.istio.io/v1alpha3<br>kind: VirtualService<br>metadata:<br>  name: argo-dashboard<br>  namespace: argo-rollouts<br>spec:<br>  hosts:<br>  -  &quot;argo-rollouts-dashboard&quot;<br>  -  &quot;dashboard-argo.k8s.raj.ninja&quot;<br>  gateways:<br>  - argo-dashboard<br>  http:<br>  - route:<br>    - destination:<br>        host: argo-rollouts-dashboard<br>        port:<br>          number: 3100<br>    retries:<br>      perTryTimeout: 500ms<br>      retryOn: 5xx,gateway-error,connect-failure,refused-stream<br>---</pre>
<p>Agora tendo acesso a dashboard, podemos utilizar a mesma para manipular nossos rollouts de forma visual, podendo
  abortar, promover, acompanhar e dar rollback a qualquer momento com poucos clicks.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dZPgKUJ6CtxiSJLN0SLTaQ.png" /></figure>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XGAOPwyKSbsjIUVF0Ky4BQ.png" /></figure>
<p><strong>Referencias / Materiais de Apoio</strong></p>
<ul>
  <li><strong>[Argo-Rollouts — Site Oficial]</strong> <em>(</em><a
      href="https://argo-rollouts.readthedocs.io/en/stable/"><em>https://argo-rollouts.readthedocs.io/en/stable/</em></a><em>)</em>
  </li>
  <li><strong>[Argo-Rollouts — Analysis Template] </strong><em>(</em><a
      href="https://argo-rollouts.readthedocs.io/en/stable/features/analysis/"><em>https://argo-rollouts.readthedocs.io/en/stable/features/analysis/</em></a><em>)</em>
  </li>
  <li><strong>[Argo-Rollouts — Prometheus Provider] </strong><em>(</em><a
      href="https://argo-rollouts.readthedocs.io/en/stable/analysis/prometheus/"><em>https://argo-rollouts.readthedocs.io/en/stable/analysis/prometheus/</em></a><em>)</em>
  </li>
  <li><strong>[BlueGreenDeployment — Martin Fowler]</strong><em>(</em><a
      href="https://martinfowler.com/bliki/BlueGreenDeployment.html"><em>https://martinfowler.com/bliki/BlueGreenDeployment.html</em></a><em>)</em>
  </li>
  <li><strong>[Software Delivery Guide]</strong><em>(</em><a
      href="https://martinfowler.com/delivery.html"><em>https://martinfowler.com/delivery.html</em></a><em>)</em></li>
  <li><strong>[Kubernetes Deployments </strong><em>(</em><a
      href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"><em>https://kubernetes.io/docs/concepts/workloads/controllers/deployment</em></a><em>)</em>
  </li>
  <li><strong>[ArgoProject — Argo Rollouts]</strong>(<a
      href="https://argoproj.github.io/argo-rollouts/FAQ/"><em>https://argoproj.github.io/argo-rollouts/FAQ/</em></a>)
  </li>
</ul>
<p><strong>Obrigado aos revisores:</strong></p>
<ul>
  <li><strong>Carlos Panato</strong> — (<a
      href="https://twitter.com/comedordexis"><strong><em>@comedordexis</em></strong></a>)</li>
  <li><strong>Bernardo</strong> — (<a
      href="https://twitter.com/indiepagodeiro"><strong><em>@indiepagodeiro</em></strong></a>)</li>
  <li><strong>Caio Volpato </strong>— <strong>(</strong><a
      href="https://twitter.com/caioauv"><strong><em>@caioauv</em></strong></a><strong>)</strong></li>
  <li><strong>Diego Murta Freire — (</strong><a
      href="https://twitter.com/diogomurta"><strong><em>@diegomurta</em></strong></a><strong>)</strong></li>
  <li><strong>Marcelo Freire — (</strong><a href="https://twitter.com/marcelofreire28"><strong><em>@
          marcelofreire28</em></strong></a><strong>)</strong></li>
</ul>
<p><strong>Playlist que eu estava ouvindo enquanto escrevia isso aqui</strong></p><iframe
  src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fopen.spotify.com%2Fembed%2Fplaylist%2F7hWZuMiKwfo85yi5WLT5PR%3Futm_source%3Doembed&amp;display_name=Spotify&amp;url=https%3A%2F%2Fopen.spotify.com%2Fplaylist%2F7hWZuMiKwfo85yi5WLT5PR&amp;image=https%3A%2F%2Fmosaic.scdn.co%2F300%2Fab67616d00001e0255d00a84eaa247ef1dacc46dab67616d00001e02c11f5969e0c8a16734fcdff7ab67616d00001e02eb56285e5977b1c57a3484a9ab67616d00001e02f9b086ac6765f6300968235a&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=spotify"
  width="456" height="352" frameborder="0" scrolling="no"><a
    href="https://medium.com/media/9d74eed87f35d090ebf109e92bb83b2f/href">https://medium.com/media/9d74eed87f35d090ebf109e92bb83b2f/href</a></iframe>
<p>Me <a href="https://twitter.com/fidelissauro"><strong>sigam no Twitter</strong></a> para acompanhar as paradinhas que
  eu compartilho por lá!</p>
<p>Te ajudei de alguma forma? Me pague um café (<em>Mentira, todos os valores doados nessa chave são dobrados por mim e
    destinados a ongs de apoio e resgate animal</em>)</p>
<p><strong>Chave Pix:</strong> <em>fe60fe92-ecba-4165-be5a-3dccf8a06bfc</em></p><img
  src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e030c2ee3af5" width="1"
  height="1" alt="">