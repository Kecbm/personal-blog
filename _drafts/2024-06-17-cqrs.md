---
layout: post
image: assets/images/system-design/escalabilidade-capa.png
author: matheus
featured: false
published: true
categories: [ system-design, engineering, cloud ]
title: System Design - CQRS
---

# Definindo CQRS

O CQRS, ou **Comand Query Responsability Segregation** é um **padrão arquitetural cujo objetivo é separar as responsabilidades de escrita e leitura de um sistema**. As operações de escrita no padrão do CQRS são denominadas como "comandos", pois entende-se que a implementação de escrita do CQRS seja voltada para efetuar operações imperativas que mudem o estado de uma ou mais entidade do sistema, e as operações de leitura são denominadas como "query", cujo objetivo é apenas fornecer uma capacidade de leitura dos dados desse domínio de forma otimizada. 

O objetivo central do CQRS é **aumentar a performance e a escalabilidade de um serviço através de modelos de dados que sejam especificamente otimizados para suas tarefas**, apostando na teoria de que ao separar as operação de comandos e consultas, cada parte do sistema pode ser escalada independentemente, permitindo uma utilização mais eficiente dos recursos computacionais alocados para cada uma dessas tarefas. 

Se eu pudesse resumir toda a proposta de forma simplista, o padrão se refere basicamente a ter dois ou mais bancos de dados com seus dados replicados, porém com suas  garantindo requisitos especialistas. Iremos abordar essa proposta mediante a outras abordagens um pouco mais complexas poderosas ao decorrer do capítulo. 

## Separação de Responsabilidades

O princípio central do CQRS é a separação de responsabilidades entre operações de leitura e operações de escrita entre infraestruturas e modelos de dados diferentes. 

Os **commands** encapsulam todas as informações necessárias para realizar uma operação de escrita, como criar, atualizar ou deletar um registro, além de aplicarem todas as regras de validação necessárias para garantir os níveis de integridade do dado. Conceitualmente o comando tende a se referir ao ato de "processar algo", alterar um estado mediante a um estimulo de um comportamento, porém também podem ser aplicado para manipular entidades anêmicas caso necessário. O modelo de escrita deve focar em garantir a consistência e integridade dos dados. É comum usar bancos de dados relacionais que suportem transações e garantam [ACID (Atomicidade, Consistência, Isolamento, Durabilidade)]() para garantir a consistência e executar as transações de forma atômica. Os bancos de dados de escrita que precisam garantir uma consistência forte contam com processos de normalização para otimizar a performance e integridade. 

As **queries** são responsáveis por **retornar dados sem alterar o estado do sistema**. Os bancos de dados são otimizados para **recuperação rápida e eficiente de informações**, muitas vezes utilizando técnicas como **caching, replicas de leitura ou desnormalização de dados** para melhorar o desempenho para esse tipo de cenário. Bancos de dados NoSQL são frequentemente usados aqui, pois oferecem alta performance em consultas e podem escalar horizontalmente de forma eficaz, mas o uso pode ser encontrado em bancos SQL normalmente de forma desnormalizada.

Em resumo, um exemplo mais simples de aplicação do CQRS seria fazer uso de um modelo normalizado dentro de um banco SQL de escrita para garantir toda a consistência e integridade e a partir dos eventos de comando, e em seguida estimular uma segunda escrita em outra base de dados com uma view materializada e desnormalizada otimizada para ser recuparada, ou em um banco NoSQL com a estrutura do documento muito proxima do payload de response.

### Perspectiva sobre Modelos de Domínio

O modelo de comando é responsável por manipular os dados do sistema e garantir a consistência e integridade das operações. Este modelo é geralmente mais complexo, pois incorpora todas as regras de negócio, validações e lógica que precisam ser aplicadas quando o estado do sistema é alterado. O modelo de comando frequentemente segue o padrão **Rich Domain Model**, onde a lógica de negócio está embutida nas entidades do domínio e fazendo uso de transações ACID para garantir mudanças de estado consistentes durante o ciclo de vida dos dados de domínio. Vamos desenhar um cenário onde no nosso sistema de prontuários, caso o médico precise criar uma nova prescrição para o paciente, a ação de command deverá ver se o médico é válido, verificar se o paciente é válido, verificar se o medicamento existe, verificar se o médico está autorizado a prescrever o medicamento de acordo com sua especialidade e por fim realizar a persistência no banco de dados. Toda essa lógica será encapsulada dentro do comando. 

O modelo de consulta é otimizado para leitura e recuperação rápida de dados. Diferentemente do modelo de comando, ele não precisa incorporar lógica de negócio complexa ou validações, pois sua responsabilidade é exclusivamente fornecer dados para serem exibidos ou utilizados em outras partes do sistema depois que um comando já foi executado. Como por exemplo um modelo desnormalizado das prescrições pode ser criado para agrupar de forma legível e rápida as informações do médico, paciente e de

## Modelos de Implementação 

### Monolitos e CQRS

Um dos exemplos mais simples de uma implementação CQRS é de fato transpor um modelo SQL normalizado para outro modelo SQL desnormalizado. A simplicidade dessa abordagem permite que essa nova tabela desnormalizada eteja ou não presente na mesma instância ou schema que o restante das tabelas normalizadas dos domínios. A evolução para um database apartado é um passo que pode ocorrer também com facilidade, porém necessitaria de processos e infraestruturas adicionais caso necessário. 

Vamos trabalhar com o modelo de uma funcionalidade de prescrição de medicamentos de um sistema hospitalar fictício, onde teremos as tabelas Medicos, Pacientes, Medicamentos, Prescricoes e Prescricao_Medicamentos que fará o vinculo de 1:N dos medicamentos preescritos. Esse modelo fornece uma consistência forte de relacionamentos não permitindo que medicamentos não cadastrados sejam prescritos, pacientes não cadastrados sejam tratados e medicos não cadastrados operem e prescrevam medicamentos. 

![CQRS](/assets/images/system-design/cqrs-database-write.png)

```sql
CREATE TABLE IF NOT EXISTS Medicos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(255) NOT NULL,
    especialidade VARCHAR(255) NOT NULL,
    crm VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS Pacientes (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(255) NOT NULL,
    data_nascimento DATE NOT NULL,
    endereco VARCHAR(255)
);

CREATE TABLE IF NOT EXISTS Medicamentos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(255) NOT NULL,
    descricao TEXT
);

CREATE TABLE IF NOT EXISTS Prescricoes (
    id SERIAL PRIMARY KEY,
    id_medico INT NOT NULL,
    id_paciente INT NOT NULL,
    data_prescricao TIMESTAMP NOT NULL,
    FOREIGN KEY (id_medico) REFERENCES Medicos(id),
    FOREIGN KEY (id_paciente) REFERENCES Pacientes(id)
);

CREATE TABLE IF NOT EXISTS Prescricao_Medicamentos (
    id SERIAL PRIMARY KEY,
    id_prescricao INT NOT NULL,
    id_medicamento INT NOT NULL,
    horario VARCHAR(50) NOT NULL,
    dosagem VARCHAR(50) NOT NULL,
    FOREIGN KEY (id_prescricao) REFERENCES Prescricoes(id),
    FOREIGN KEY (id_medicamento) REFERENCES Medicamentos(id)
);
```
> Exemplo da modelagem de escrita normalizada

Esse modelo, por mais que seja superficial, garante a integridade dos dados durante a manipulação dos mesmos. Porém uma outra funcionalidade do sistema de prescrição médica é gerar relatórios e ordens de serviço para a farmácia hospitalar preparar e controlar a saída do estoque dos medicamentos. Essa funcionalidade é crítica pois os medicamentos precisam de triagem, rastreio, contabilidade e facilidade visual para separação e destinação ao quarto/enfermaria onde o paciente se encontra. Para montar uma visão como essa, em sistemas altamente normalizados, é necessário uma grande quantidade de joins entre as tabelas. 

```sql
SELECT
    p.id AS id_prescricao,
    p.data_prescricao,
    m.nome AS nome_medico,
    m.especialidade,
    pac.nome AS nome_paciente,
    pac.data_nascimento,
    pac.endereco,
    med.nome AS nome_medicamento,
    pm.horario,
    pm.dosagem
FROM
    Prescricoes p
    LEFT JOIN Medicos m ON p.id_medico = m.id
    LEFT JOIN Pacientes pac ON p.id_paciente = pac.id
    LEFT JOIN Prescricao_Medicamentos pm ON p.id = pm.id_prescricao
    LEFT JOIN Medicamentos med ON pm.id_medicamento = med.id
WHERE
    p.id = 1; -- ID da prescrição específica
```

#### Output

```
1	2023-05-20 14:30:00.000	Dr. João Silva	Cardiologia	Maria Oliveira	1985-07-10	Rua das Flores, 123	Aspirina	08:00	100mg
1	2023-05-20 14:30:00.000	Dr. João Silva	Cardiologia	Maria Oliveira	1985-07-10	Rua das Flores, 123	Paracetamol	20:00	500mg
1	2023-05-20 14:30:00.000	Dr. João Silva	Cardiologia	Maria Oliveira	1985-07-10	Rua das Flores, 123	Aspirina	08:00	100mg
```

Para externalizar essa consulta para um modelo especializado, a primeira possibilidade seria criar uma segunda tabela semi-desnormalizada, mantendo apenas a consistência entre ids e relacionamentos evitando corrupção a um nível basico e colocando em linha a prescricao do medicamento de forma descritiva, eliminando a nacessidade de Joins entre tabelas a todo instante, entregando a view especifica para o subsistema de farmacia. 

![CQRS](/assets/images/system-design/cqrs-database-read-prescricoes.png)

```sql
CREATE TABLE IF NOT EXISTS vw_prescricoes_medicamentos_detalhadas (
	id SERIAL PRIMARY KEY,
    id_prescricao INT,
    data_prescricao TIMESTAMP NOT NULL,
    id_medico INT NOT NULL,
    nome_medico VARCHAR(255) NOT NULL,
    especialidade_medico VARCHAR(255) NOT NULL,
    crm_medico VARCHAR(8) NOT NULL,
    id_paciente INT NOT NULL,
    nome_paciente VARCHAR(255) NOT NULL,
    data_nascimento_paciente DATE NOT NULL,
    endereco_paciente VARCHAR(255),
    id_medicamento INT NOT NULL,
    nome_medicamento VARCHAR(255) NOT NULL,
    descricao_medicamento TEXT,
    horario VARCHAR(50) NOT NULL,
    dosagem VARCHAR(50) NOT null,
    FOREIGN KEY (id_medico) REFERENCES Medicos(id),
    FOREIGN KEY (id_paciente) REFERENCES Pacientes(id),
    FOREIGN KEY (id_medicamento) REFERENCES Medicamentos(id),
    FOREIGN KEY (id_prescricao) REFERENCES Prescricoes(id)
);
```

Para ilustrar inicialmente, supondo que a tabela otimizada para consulta se encontra presente no mesmo database, podemos iniciar uma carga com os dados presentes localmente, utilizando como base a query anterior com todos os joins necessários. E em seguida conseguiremos simplificar a busca dos dados da prescrição de forma detalhada apenas com um select simples em uma única tabela analitica com os dados compilados. 

```sql
INSERT INTO vw_prescricoes_medicamentos_detalhadas (
    id_prescricao,
    data_prescricao,
    id_medico,
    nome_medico,
    especialidade_medico,
    crm_medico,
    id_paciente,
    nome_paciente,
    data_nascimento_paciente,
    endereco_paciente,
    id_medicamento,
    nome_medicamento,
    descricao_medicamento,
    horario,
    dosagem
)
SELECT
    p.id AS id_prescricao,
    p.data_prescricao,
    m.id AS id_medico,
    m.nome AS nome_medico,
    m.especialidade AS especialidade_medico,
    m.crm as crm_medico,
    pac.id AS id_paciente,
    pac.nome AS nome_paciente,
    pac.data_nascimento AS data_nascimento_paciente,
    pac.endereco AS endereco_paciente,
    med.id AS id_medicamento,
    med.nome AS nome_medicamento,
    med.descricao AS descricao_medicamento,
    pm.horario,
    pm.dosagem
FROM
    Prescricoes p
    JOIN Medicos m ON p.id_medico = m.id
    JOIN Pacientes pac ON p.id_paciente = pac.id
    JOIN Prescricao_Medicamentos pm ON p.id = pm.id_prescricao
    JOIN Medicamentos med ON pm.id_medicamento = med.id;
```
> Exemplo de carregamento inicial da tabela de view com os dados presentes no modelo normalizado

```sql
SELECT * FROM vw_prescricoes_medicamentos_detalhadas WHERE id_prescricao = 1;
```

```
1	1	2023-05-20 14:30:00.000	1	Dr. João Silva	Cardiologia	CRM12345	1	Maria Oliveira	1985-07-10	Rua das Flores, 123	1	Aspirina	Analgésico e anti-inflamatório	08:00	100mg
2	1	2023-05-20 14:30:00.000	1	Dr. João Silva	Cardiologia	CRM12345	1	Maria Oliveira	1985-07-10	Rua das Flores, 123	2	Paracetamol	Analgésico	20:00	500mg
20	1	2023-05-20 14:30:00.000	1	Dr. João Silva	Cardiologia	CRM12345	1	Maria Oliveira	1985-07-10	Rua das Flores, 123	1	Aspirina	Analgésico e anti-inflamatório	08:00	100mg
```

Esse tipo de estratégia é muito comum para criar visualizações especializadas em diversos tipos de sistema, e viabiliza algumas abordagens interessantes de segregação de responsabilidade escrita e leitura de forma simplificada, porém executar o carregamento de dados como o exemplo ilustrado é inviável em sistemas transacionais com volume considerável, uma vez que executar o select da database inteira para carregar em uma tabela especializada não resolveria, e talvez agravaria problemas de escala de uso desses dados. Para isso precisamos adicionar responsabilidades adicionais ao modelo de comando, e contar muitas vezes com a consistência eventual dos modelos de leitura. 

![CQRS Exemplo](/assets/images/system-design/cqrs-conceitual.png)

Para realizar a sincronização entre os modelos de escrita e leitura de forma saudável, o uso de mensageria e eventos como intermediário entre ambos pode ajudar a desacoplar as responsabilidades e fazer com que ambas escalem independentemente uma da outra, porém a consistência eventual é um side-effect que é necessário ser contabilizado no desenho de arquitetura para viabilizar esse comportamento.  

<br>

### Consistência Eventual no CQRS

No contexto de CQRS a consistência eventual é um conceito que pode ser muito valioso quando aceito e previsto no desenho de solução. Diferente de sistemas tradicionais que podem garantir uma consistência imediata entre os modelos de dados, **aceitar o comportamento de um sistema eventualmente consistente pressupõe que um sistema pode transacionar por um periodo de tempo de forma inconsistente sem grandes problemas**, e que também presume que com o tempo, o **sistema ou entidade ficará consistente em algum momento**. 

Na pratica, olhando para uma implementação CQRS que suporte esse tipo de cenário, os modelos de comando e consulta são separados, e **as operações de escrita são processadas no modelo de comando e, em seguida, eventos ou mensagens são gerados para atualizar o modelo de consulta**. Como esses eventos podem ser processados de forma assíncrona, **pode haver um atraso antes que o modelo de consulta reflita as últimas mudanças** realizadas no modelo de comando. Durante esse intervalo, o sistema está em um estado de "consistência eventual".

![CQRS Evento](/assets/images/system-design/cqrs-eventual.png)

Para realizar a sincroniza entre modelos **são necessários esforços computacionais adicionais**, sejam eles processos e listeners assincronos ou aplicações de sync totalmente separadas que escutam tópicos ou filas e realizarem a escrita no modelo de leitura criando views otimizadas. Esse processo pressupõe um comportamento adicional independente e que não deve impactar a performance de forma agressiva. 


> Exemplo de uma query para recuperar as prescrições

![CQRS Command Async](/assets/images/system-design/cqrs-comando-async.png)

![CQRS NoSQL](/assets/images/system-design/cqrs-nosql.png)

![CQRS Read Replica](/assets/images/system-design/cqrs-read-replica.png)

![CQRS Dual Write](/assets/images/system-design/cqrs-dual-write.png)

![CQRS Dual Write Rollback](/assets/images/system-design/cqrs-dual-write-rollback.png)

![CQRS Dual Write Rollback](/assets/images/system-design/cqrs-dual-write-rollback-1.png)

Desnormalizar

![CQRS](/assets/images/system-design/cqrs-database-read-prescricoes.png)




```js
{
    id_prescricao: 123,
    data_prescricao: new Date('2023-05-20T14:30:00Z'),
    medico: {
        id_medico: 1,
        nome: "Dr. Who",
        especialidade: "Cardiologia",
        crm: "123123"
    },
    paciente: {
        id_paciente: 1,
        nome: "Matheus S. Fidelis",
        data_nascimento: new Date('1985-07-10'),
        endereco: "Rua das Flores, 123"
    },
    medicamentos: [
        {
            id_medicamento: 1,
            nome: "Aspirina",
            descricao: "Analgésico e anti-inflamatório",
            horario: "08:00",
            dosagem: "100mg"
        },
        {
            id_medicamento: 2,
            nome: "Paracetamol",
            descricao: "Analgésico",
            horario: "20:00",
            dosagem: "500mg"
        }
    ]
}
```
> Exemplo do dado desnormalizado em um padrão NoSQL - Ex: MongoDB

## Microserviços e CQRS

## Exemplos e Abordagens

### Revisores

* [Tarsila, o amor da minha vida](https://twitter.com/tarsilabianca_c)


<br>

### Referencias

[Centro de Arquitetura Microsoft - Padrão CQRS](https://learn.microsoft.com/pt-br/azure/architecture/patterns/cqrs)

[CQRS – O que é? Onde aplicar?](https://www.eduardopires.net.br/2016/07/cqrs-o-que-e-onde-aplicar/)

[CQRS (Command Query Responsibility Segregation) em uma Arquitetura de Microsserviços](https://medium.com/@marcelomg21/cqrs-command-query-responsibility-segregation-em-uma-arquitetura-de-micro-servi%C3%A7os-71dcb687a8a9)

[Amazon AWS - Padrão CQRS](https://docs.aws.amazon.com/pt_br/prescriptive-guidance/latest/modernization-data-persistence/cqrs-pattern.html)

[Martin Fowler - CQRS](https://www.martinfowler.com/bliki/CQRS.html)

[Gitlab - CQRS](https://ajuda.gitlab.io/guia-rapido/arquitetura/design-patterns/cqrs/)

[Command Query Responsibility Segregation (CQRS)](https://developer.confluent.io/courses/event-sourcing/cqrs/)

[Pattern: Command Query Responsibility Segregation (CQRS)](https://microservices.io/patterns/data/cqrs.html)